   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.setPinInputHigh_atomic,"ax",@progbits
  12               	setPinInputHigh_atomic:
  13               	.LVL0:
  14               	.LFB118:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2018 Jun Wako, Jack Humbert, Yiancar
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #include "util.h"
  20:quantum/matrix.c **** #include "matrix.h"
  21:quantum/matrix.c **** #include "debounce.h"
  22:quantum/matrix.c **** #include "quantum.h"
  23:quantum/matrix.c **** 
  24:quantum/matrix.c **** #ifdef DIRECT_PINS
  25:quantum/matrix.c **** static pin_t direct_pins[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS;
  26:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  27:quantum/matrix.c **** static const pin_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  28:quantum/matrix.c **** static const pin_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  29:quantum/matrix.c **** #endif
  30:quantum/matrix.c **** 
  31:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  32:quantum/matrix.c **** extern matrix_row_t raw_matrix[MATRIX_ROWS];  // raw values
  33:quantum/matrix.c **** extern matrix_row_t matrix[MATRIX_ROWS];      // debounced values
  34:quantum/matrix.c **** 
  35:quantum/matrix.c **** static inline void setPinOutput_writeLow(pin_t pin) {
  36:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
  37:quantum/matrix.c ****         setPinOutput(pin);
  38:quantum/matrix.c ****         writePinLow(pin);
  39:quantum/matrix.c ****     }
  40:quantum/matrix.c **** }
  41:quantum/matrix.c **** 
  42:quantum/matrix.c **** static inline void setPinInputHigh_atomic(pin_t pin) {
  16               		.loc 1 42 54 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  43:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON { setPinInputHigh(pin); }
  22               		.loc 1 43 5 view .LVU1
  23               	.LBB15:
  24               		.loc 1 43 5 view .LVU2
  25               	.LBB16:
  26               	.LBI16:
  27               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
   4:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
   7:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  10:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****      distribution.
  14:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  15:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  19:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** */
  31:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  32:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  34:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  37:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  40:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** {
  44:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     sei();
  45:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     return 1;
  46:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** }
  47:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  28               		.loc 2 48 27 view .LVU3
  29               	.LBB17:
  49:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** {
  50:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     cli();
  30               		.loc 2 50 5 view .LVU4
  31               	/* #APP */
  32               	 ;  50 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h" 1
  33 0000 F894      		cli
  34               	 ;  0 "" 2
  51:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     return 1;
  35               		.loc 2 51 5 view .LVU5
  36               	.LVL1:
  37               		.loc 2 51 5 is_stmt 0 view .LVU6
  38               	/* #NOAPP */
  39               	.LBE17:
  40               	.LBE16:
  41               		.loc 1 43 5 is_stmt 1 view .LVU7
  42               		.loc 1 43 28 view .LVU8
  43 0002 E82F      		mov r30,r24
  44 0004 E295      		swap r30
  45 0006 EF70      		andi r30,lo8(15)
  46 0008 F0E0      		ldi r31,0
  47 000a 31A1      		ldd r19,Z+33
  48 000c 282F      		mov r18,r24
  49 000e 2F70      		andi r18,lo8(15)
  50 0010 81E0      		ldi r24,lo8(1)
  51 0012 90E0      		ldi r25,0
  52               	.LVL2:
  53               		.loc 1 43 28 is_stmt 0 view .LVU9
  54 0014 00C0      		rjmp 2f
  55               		1:
  56 0016 880F      		lsl r24
  57               		2:
  58 0018 2A95      		dec r18
  59 001a 02F4      		brpl 1b
  60 001c 982F      		mov r25,r24
  61 001e 9095      		com r25
  62 0020 9323      		and r25,r19
  63 0022 91A3      		std Z+33,r25
  64 0024 92A1      		ldd r25,Z+34
  65 0026 892B      		or r24,r25
  66 0028 82A3      		std Z+34,r24
  67               		.loc 1 43 5 is_stmt 1 view .LVU10
  68               	.LVL3:
  69               		.loc 1 43 5 view .LVU11
  70               	.LBB18:
  71               	.LBI18:
  52:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** }
  53:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** 
  54:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  72               		.loc 2 54 24 view .LVU12
  73               	.LBB19:
  55:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** {
  56:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     sei();
  74               		.loc 2 56 5 view .LVU13
  75               	/* #APP */
  76               	 ;  56 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h" 1
  77 002a 7894      		sei
  78               	 ;  0 "" 2
  57:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  79               		.loc 2 57 5 view .LVU14
  58:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     (void)__s;
  80               		.loc 2 58 5 view .LVU15
  81               	.LVL4:
  82               	/* #NOAPP */
  83               	/* epilogue start */
  84               		.loc 2 58 5 is_stmt 0 view .LVU16
  85               	.LBE19:
  86               	.LBE18:
  87               	.LBE15:
  44:quantum/matrix.c **** }
  88               		.loc 1 44 1 view .LVU17
  89 002c 0895      		ret
  90               		.cfi_endproc
  91               	.LFE118:
  93               		.section	.text.matrix_init,"ax",@progbits
  94               	.global	matrix_init
  96               	matrix_init:
  97               	.LFB124:
  45:quantum/matrix.c **** 
  46:quantum/matrix.c **** // matrix code
  47:quantum/matrix.c **** 
  48:quantum/matrix.c **** #ifdef DIRECT_PINS
  49:quantum/matrix.c **** 
  50:quantum/matrix.c **** static void init_pins(void) {
  51:quantum/matrix.c ****     for (int row = 0; row < MATRIX_ROWS; row++) {
  52:quantum/matrix.c ****         for (int col = 0; col < MATRIX_COLS; col++) {
  53:quantum/matrix.c ****             pin_t pin = direct_pins[row][col];
  54:quantum/matrix.c ****             if (pin != NO_PIN) {
  55:quantum/matrix.c ****                 setPinInputHigh(pin);
  56:quantum/matrix.c ****             }
  57:quantum/matrix.c ****         }
  58:quantum/matrix.c ****     }
  59:quantum/matrix.c **** }
  60:quantum/matrix.c **** 
  61:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
  62:quantum/matrix.c ****     // Start with a clear matrix row
  63:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
  64:quantum/matrix.c **** 
  65:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
  66:quantum/matrix.c ****         pin_t pin = direct_pins[current_row][col_index];
  67:quantum/matrix.c ****         if (pin != NO_PIN) {
  68:quantum/matrix.c ****             current_row_value |= readPin(pin) ? 0 : (MATRIX_ROW_SHIFTER << col_index);
  69:quantum/matrix.c ****         }
  70:quantum/matrix.c ****     }
  71:quantum/matrix.c **** 
  72:quantum/matrix.c ****     // If the row has changed, store the row and return the changed flag.
  73:quantum/matrix.c ****     if (current_matrix[current_row] != current_row_value) {
  74:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
  75:quantum/matrix.c ****         return true;
  76:quantum/matrix.c ****     }
  77:quantum/matrix.c ****     return false;
  78:quantum/matrix.c **** }
  79:quantum/matrix.c **** 
  80:quantum/matrix.c **** #elif defined(DIODE_DIRECTION)
  81:quantum/matrix.c **** #    if (DIODE_DIRECTION == COL2ROW)
  82:quantum/matrix.c **** 
  83:quantum/matrix.c **** static void select_row(uint8_t row) { setPinOutput_writeLow(row_pins[row]); }
  84:quantum/matrix.c **** 
  85:quantum/matrix.c **** static void unselect_row(uint8_t row) { setPinInputHigh_atomic(row_pins[row]); }
  86:quantum/matrix.c **** 
  87:quantum/matrix.c **** static void unselect_rows(void) {
  88:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
  89:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
  90:quantum/matrix.c ****     }
  91:quantum/matrix.c **** }
  92:quantum/matrix.c **** 
  93:quantum/matrix.c **** static void init_pins(void) {
  94:quantum/matrix.c ****     unselect_rows();
  95:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
  96:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
  97:quantum/matrix.c ****     }
  98:quantum/matrix.c **** }
  99:quantum/matrix.c **** 
 100:quantum/matrix.c **** static bool read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_row) {
 101:quantum/matrix.c ****     // Start with a clear matrix row
 102:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
 103:quantum/matrix.c **** 
 104:quantum/matrix.c ****     // Select row
 105:quantum/matrix.c ****     select_row(current_row);
 106:quantum/matrix.c ****     matrix_output_select_delay();
 107:quantum/matrix.c **** 
 108:quantum/matrix.c ****     // For each col...
 109:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 110:quantum/matrix.c ****         // Select the col pin to read (active low)
 111:quantum/matrix.c ****         uint8_t pin_state = readPin(col_pins[col_index]);
 112:quantum/matrix.c **** 
 113:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 114:quantum/matrix.c ****         current_row_value |= pin_state ? 0 : (MATRIX_ROW_SHIFTER << col_index);
 115:quantum/matrix.c ****     }
 116:quantum/matrix.c **** 
 117:quantum/matrix.c ****     // Unselect row
 118:quantum/matrix.c ****     unselect_row(current_row);
 119:quantum/matrix.c ****     if (current_row + 1 < MATRIX_ROWS) {
 120:quantum/matrix.c ****         matrix_output_unselect_delay();  // wait for row signal to go HIGH
 121:quantum/matrix.c ****     }
 122:quantum/matrix.c **** 
 123:quantum/matrix.c ****     // If the row has changed, store the row and return the changed flag.
 124:quantum/matrix.c ****     if (current_matrix[current_row] != current_row_value) {
 125:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
 126:quantum/matrix.c ****         return true;
 127:quantum/matrix.c ****     }
 128:quantum/matrix.c ****     return false;
 129:quantum/matrix.c **** }
 130:quantum/matrix.c **** 
 131:quantum/matrix.c **** #    elif (DIODE_DIRECTION == ROW2COL)
 132:quantum/matrix.c **** 
 133:quantum/matrix.c **** static void select_col(uint8_t col) { setPinOutput_writeLow(col_pins[col]); }
 134:quantum/matrix.c **** 
 135:quantum/matrix.c **** static void unselect_col(uint8_t col) { setPinInputHigh_atomic(col_pins[col]); }
 136:quantum/matrix.c **** 
 137:quantum/matrix.c **** static void unselect_cols(void) {
 138:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 139:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 140:quantum/matrix.c ****     }
 141:quantum/matrix.c **** }
 142:quantum/matrix.c **** 
 143:quantum/matrix.c **** static void init_pins(void) {
 144:quantum/matrix.c ****     unselect_cols();
 145:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 146:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 147:quantum/matrix.c ****     }
 148:quantum/matrix.c **** }
 149:quantum/matrix.c **** 
 150:quantum/matrix.c **** static bool read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_col) {
 151:quantum/matrix.c ****     bool matrix_changed = false;
 152:quantum/matrix.c **** 
 153:quantum/matrix.c ****     // Select col
 154:quantum/matrix.c ****     select_col(current_col);
 155:quantum/matrix.c ****     matrix_output_select_delay();
 156:quantum/matrix.c **** 
 157:quantum/matrix.c ****     // For each row...
 158:quantum/matrix.c ****     for (uint8_t row_index = 0; row_index < MATRIX_ROWS; row_index++) {
 159:quantum/matrix.c ****         // Store last value of row prior to reading
 160:quantum/matrix.c ****         matrix_row_t last_row_value    = current_matrix[row_index];
 161:quantum/matrix.c ****         matrix_row_t current_row_value = last_row_value;
 162:quantum/matrix.c **** 
 163:quantum/matrix.c ****         // Check row pin state
 164:quantum/matrix.c ****         if (readPin(row_pins[row_index]) == 0) {
 165:quantum/matrix.c ****             // Pin LO, set col bit
 166:quantum/matrix.c ****             current_row_value |= (MATRIX_ROW_SHIFTER << current_col);
 167:quantum/matrix.c ****         } else {
 168:quantum/matrix.c ****             // Pin HI, clear col bit
 169:quantum/matrix.c ****             current_row_value &= ~(MATRIX_ROW_SHIFTER << current_col);
 170:quantum/matrix.c ****         }
 171:quantum/matrix.c **** 
 172:quantum/matrix.c ****         // Determine if the matrix changed state
 173:quantum/matrix.c ****         if ((last_row_value != current_row_value)) {
 174:quantum/matrix.c ****             matrix_changed |= true;
 175:quantum/matrix.c ****             current_matrix[row_index] = current_row_value;
 176:quantum/matrix.c ****         }
 177:quantum/matrix.c ****     }
 178:quantum/matrix.c **** 
 179:quantum/matrix.c ****     // Unselect col
 180:quantum/matrix.c ****     unselect_col(current_col);
 181:quantum/matrix.c ****     if (current_col + 1 < MATRIX_COLS) {
 182:quantum/matrix.c ****         matrix_output_unselect_delay();  // wait for col signal to go HIGH
 183:quantum/matrix.c ****     }
 184:quantum/matrix.c **** 
 185:quantum/matrix.c ****     return matrix_changed;
 186:quantum/matrix.c **** }
 187:quantum/matrix.c **** 
 188:quantum/matrix.c **** #    else
 189:quantum/matrix.c **** #        error DIODE_DIRECTION must be one of COL2ROW or ROW2COL!
 190:quantum/matrix.c **** #    endif
 191:quantum/matrix.c **** #else
 192:quantum/matrix.c **** #    error DIODE_DIRECTION is not defined!
 193:quantum/matrix.c **** #endif
 194:quantum/matrix.c **** 
 195:quantum/matrix.c **** void matrix_init(void) {
  98               		.loc 1 195 24 is_stmt 1 view -0
  99               		.cfi_startproc
 100 0000 0F93      		push r16
 101               	.LCFI0:
 102               		.cfi_def_cfa_offset 3
 103               		.cfi_offset 16, -2
 104 0002 1F93      		push r17
 105               	.LCFI1:
 106               		.cfi_def_cfa_offset 4
 107               		.cfi_offset 17, -3
 108 0004 CF93      		push r28
 109               	.LCFI2:
 110               		.cfi_def_cfa_offset 5
 111               		.cfi_offset 28, -4
 112 0006 DF93      		push r29
 113               	.LCFI3:
 114               		.cfi_def_cfa_offset 6
 115               		.cfi_offset 29, -5
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 4 */
 119               	.L__stack_usage = 4
 196:quantum/matrix.c ****     // initialize key pins
 197:quantum/matrix.c ****     init_pins();
 120               		.loc 1 197 5 view .LVU19
 121               	.LBB27:
 122               	.LBI27:
  93:quantum/matrix.c ****     unselect_rows();
 123               		.loc 1 93 13 view .LVU20
 124               	.LBE27:
  94:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 125               		.loc 1 94 5 view .LVU21
 126               	.LBB31:
 127               	.LBB28:
 128               	.LBI28:
  87:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_ROWS; x++) {
 129               		.loc 1 87 13 view .LVU22
 130               	.LVL5:
 131               	.LBB29:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 132               		.loc 1 88 25 view .LVU23
  89:quantum/matrix.c ****     }
 133               		.loc 1 89 9 view .LVU24
 134 0008 80E9      		ldi r24,lo8(-112)
 135 000a 0E94 0000 		call setPinInputHigh_atomic
 136               	.LVL6:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 137               		.loc 1 88 42 view .LVU25
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 138               		.loc 1 88 25 view .LVU26
  89:quantum/matrix.c ****     }
 139               		.loc 1 89 9 view .LVU27
 140 000e 81E9      		ldi r24,lo8(-111)
 141 0010 0E94 0000 		call setPinInputHigh_atomic
 142               	.LVL7:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 143               		.loc 1 88 42 view .LVU28
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 144               		.loc 1 88 25 view .LVU29
  89:quantum/matrix.c ****     }
 145               		.loc 1 89 9 view .LVU30
 146 0014 82E9      		ldi r24,lo8(-110)
 147 0016 0E94 0000 		call setPinInputHigh_atomic
 148               	.LVL8:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 149               		.loc 1 88 42 view .LVU31
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 150               		.loc 1 88 25 view .LVU32
  89:quantum/matrix.c ****     }
 151               		.loc 1 89 9 view .LVU33
 152 001a 83E9      		ldi r24,lo8(-109)
 153 001c 0E94 0000 		call setPinInputHigh_atomic
 154               	.LVL9:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 155               		.loc 1 88 42 view .LVU34
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 156               		.loc 1 88 25 view .LVU35
  89:quantum/matrix.c ****     }
 157               		.loc 1 89 9 view .LVU36
 158 0020 85E9      		ldi r24,lo8(-107)
 159 0022 0E94 0000 		call setPinInputHigh_atomic
 160               	.LVL10:
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 161               		.loc 1 88 42 view .LVU37
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 162               		.loc 1 88 25 view .LVU38
  88:quantum/matrix.c ****         setPinInputHigh_atomic(row_pins[x]);
 163               		.loc 1 88 25 is_stmt 0 view .LVU39
 164               	.LBE29:
 165               	.LBE28:
 166               	.LBB30:
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 167               		.loc 1 95 25 is_stmt 1 view .LVU40
 168 0026 C0E0      		ldi r28,lo8(col_pins)
 169 0028 D0E0      		ldi r29,hi8(col_pins)
 170 002a 00E0      		ldi r16,lo8(col_pins+15)
 171 002c 10E0      		ldi r17,hi8(col_pins+15)
 172               	.LVL11:
 173               	.L3:
  96:quantum/matrix.c ****     }
 174               		.loc 1 96 9 view .LVU41
 175 002e 8991      		ld r24,Y+
 176               	.LVL12:
  96:quantum/matrix.c ****     }
 177               		.loc 1 96 9 is_stmt 0 view .LVU42
 178 0030 0E94 0000 		call setPinInputHigh_atomic
 179               	.LVL13:
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 180               		.loc 1 95 42 is_stmt 1 view .LVU43
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 181               		.loc 1 95 25 view .LVU44
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 182               		.loc 1 95 5 is_stmt 0 view .LVU45
 183 0034 0C17      		cp r16,r28
 184 0036 1D07      		cpc r17,r29
 185 0038 01F4      		brne .L3
 186               	.LVL14:
  95:quantum/matrix.c ****         setPinInputHigh_atomic(col_pins[x]);
 187               		.loc 1 95 5 view .LVU46
 188               	.LBE30:
 189               	.LBE31:
 190               	.LBB32:
 198:quantum/matrix.c **** 
 199:quantum/matrix.c ****     // initialize matrix state: all keys off
 200:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 201:quantum/matrix.c ****         raw_matrix[i] = 0;
 191               		.loc 1 201 9 is_stmt 1 view .LVU47
 192               		.loc 1 201 23 is_stmt 0 view .LVU48
 193 003a 1092 0000 		sts raw_matrix+1,__zero_reg__
 194 003e 1092 0000 		sts raw_matrix,__zero_reg__
 202:quantum/matrix.c ****         matrix[i]     = 0;
 195               		.loc 1 202 9 is_stmt 1 view .LVU49
 196               		.loc 1 202 23 is_stmt 0 view .LVU50
 197 0042 1092 0000 		sts matrix+1,__zero_reg__
 198 0046 1092 0000 		sts matrix,__zero_reg__
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 199               		.loc 1 200 42 is_stmt 1 view .LVU51
 200               	.LVL15:
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 201               		.loc 1 200 25 view .LVU52
 201:quantum/matrix.c ****         matrix[i]     = 0;
 202               		.loc 1 201 9 view .LVU53
 201:quantum/matrix.c ****         matrix[i]     = 0;
 203               		.loc 1 201 23 is_stmt 0 view .LVU54
 204 004a 1092 0000 		sts raw_matrix+2+1,__zero_reg__
 205 004e 1092 0000 		sts raw_matrix+2,__zero_reg__
 206               		.loc 1 202 9 is_stmt 1 view .LVU55
 207               		.loc 1 202 23 is_stmt 0 view .LVU56
 208 0052 1092 0000 		sts matrix+2+1,__zero_reg__
 209 0056 1092 0000 		sts matrix+2,__zero_reg__
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 210               		.loc 1 200 42 is_stmt 1 view .LVU57
 211               	.LVL16:
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 212               		.loc 1 200 25 view .LVU58
 201:quantum/matrix.c ****         matrix[i]     = 0;
 213               		.loc 1 201 9 view .LVU59
 201:quantum/matrix.c ****         matrix[i]     = 0;
 214               		.loc 1 201 23 is_stmt 0 view .LVU60
 215 005a 1092 0000 		sts raw_matrix+4+1,__zero_reg__
 216 005e 1092 0000 		sts raw_matrix+4,__zero_reg__
 217               		.loc 1 202 9 is_stmt 1 view .LVU61
 218               		.loc 1 202 23 is_stmt 0 view .LVU62
 219 0062 1092 0000 		sts matrix+4+1,__zero_reg__
 220 0066 1092 0000 		sts matrix+4,__zero_reg__
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 221               		.loc 1 200 42 is_stmt 1 view .LVU63
 222               	.LVL17:
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 223               		.loc 1 200 25 view .LVU64
 201:quantum/matrix.c ****         matrix[i]     = 0;
 224               		.loc 1 201 9 view .LVU65
 201:quantum/matrix.c ****         matrix[i]     = 0;
 225               		.loc 1 201 23 is_stmt 0 view .LVU66
 226 006a 1092 0000 		sts raw_matrix+6+1,__zero_reg__
 227 006e 1092 0000 		sts raw_matrix+6,__zero_reg__
 228               		.loc 1 202 9 is_stmt 1 view .LVU67
 229               		.loc 1 202 23 is_stmt 0 view .LVU68
 230 0072 1092 0000 		sts matrix+6+1,__zero_reg__
 231 0076 1092 0000 		sts matrix+6,__zero_reg__
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 232               		.loc 1 200 42 is_stmt 1 view .LVU69
 233               	.LVL18:
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 234               		.loc 1 200 25 view .LVU70
 201:quantum/matrix.c ****         matrix[i]     = 0;
 235               		.loc 1 201 9 view .LVU71
 201:quantum/matrix.c ****         matrix[i]     = 0;
 236               		.loc 1 201 23 is_stmt 0 view .LVU72
 237 007a 1092 0000 		sts raw_matrix+8+1,__zero_reg__
 238 007e 1092 0000 		sts raw_matrix+8,__zero_reg__
 239               		.loc 1 202 9 is_stmt 1 view .LVU73
 240               		.loc 1 202 23 is_stmt 0 view .LVU74
 241 0082 1092 0000 		sts matrix+8+1,__zero_reg__
 242 0086 1092 0000 		sts matrix+8,__zero_reg__
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 243               		.loc 1 200 42 is_stmt 1 view .LVU75
 244               	.LVL19:
 200:quantum/matrix.c ****         raw_matrix[i] = 0;
 245               		.loc 1 200 25 view .LVU76
 246               	.LBE32:
 203:quantum/matrix.c ****     }
 204:quantum/matrix.c **** 
 205:quantum/matrix.c ****     debounce_init(MATRIX_ROWS);
 247               		.loc 1 205 5 view .LVU77
 248 008a 85E0      		ldi r24,lo8(5)
 249 008c 0E94 0000 		call debounce_init
 250               	.LVL20:
 206:quantum/matrix.c **** 
 207:quantum/matrix.c ****     matrix_init_quantum();
 251               		.loc 1 207 5 view .LVU78
 252               	/* epilogue start */
 208:quantum/matrix.c **** }
 253               		.loc 1 208 1 is_stmt 0 view .LVU79
 254 0090 DF91      		pop r29
 255 0092 CF91      		pop r28
 256               	.LVL21:
 257               		.loc 1 208 1 view .LVU80
 258 0094 1F91      		pop r17
 259 0096 0F91      		pop r16
 207:quantum/matrix.c **** }
 260               		.loc 1 207 5 view .LVU81
 261 0098 0C94 0000 		jmp matrix_init_quantum
 262               	.LVL22:
 263               		.cfi_endproc
 264               	.LFE124:
 266               		.section	.text.matrix_scan,"ax",@progbits
 267               	.global	matrix_scan
 269               	matrix_scan:
 270               	.LFB125:
 209:quantum/matrix.c **** 
 210:quantum/matrix.c **** uint8_t matrix_scan(void) {
 271               		.loc 1 210 27 is_stmt 1 view -0
 272               		.cfi_startproc
 273 0000 AF92      		push r10
 274               	.LCFI4:
 275               		.cfi_def_cfa_offset 3
 276               		.cfi_offset 10, -2
 277 0002 BF92      		push r11
 278               	.LCFI5:
 279               		.cfi_def_cfa_offset 4
 280               		.cfi_offset 11, -3
 281 0004 CF92      		push r12
 282               	.LCFI6:
 283               		.cfi_def_cfa_offset 5
 284               		.cfi_offset 12, -4
 285 0006 DF92      		push r13
 286               	.LCFI7:
 287               		.cfi_def_cfa_offset 6
 288               		.cfi_offset 13, -5
 289 0008 EF92      		push r14
 290               	.LCFI8:
 291               		.cfi_def_cfa_offset 7
 292               		.cfi_offset 14, -6
 293 000a FF92      		push r15
 294               	.LCFI9:
 295               		.cfi_def_cfa_offset 8
 296               		.cfi_offset 15, -7
 297 000c 0F93      		push r16
 298               	.LCFI10:
 299               		.cfi_def_cfa_offset 9
 300               		.cfi_offset 16, -8
 301 000e 1F93      		push r17
 302               	.LCFI11:
 303               		.cfi_def_cfa_offset 10
 304               		.cfi_offset 17, -9
 305 0010 CF93      		push r28
 306               	.LCFI12:
 307               		.cfi_def_cfa_offset 11
 308               		.cfi_offset 28, -10
 309 0012 DF93      		push r29
 310               	.LCFI13:
 311               		.cfi_def_cfa_offset 12
 312               		.cfi_offset 29, -11
 313               	/* prologue: function */
 314               	/* frame size = 0 */
 315               	/* stack size = 10 */
 316               	.L__stack_usage = 10
 211:quantum/matrix.c ****     bool changed = false;
 317               		.loc 1 211 5 view .LVU83
 318               	.LVL23:
 212:quantum/matrix.c **** 
 213:quantum/matrix.c **** #if defined(DIRECT_PINS) || (DIODE_DIRECTION == COL2ROW)
 214:quantum/matrix.c ****     // Set row, read cols
 215:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < MATRIX_ROWS; current_row++) {
 319               		.loc 1 215 5 view .LVU84
 320               	.LBB49:
 321               		.loc 1 215 10 view .LVU85
 322               		.loc 1 215 35 view .LVU86
 323 0014 00E0      		ldi r16,lo8(row_pins)
 324 0016 10E0      		ldi r17,hi8(row_pins)
 325 0018 C0E0      		ldi r28,lo8(raw_matrix)
 326 001a D0E0      		ldi r29,hi8(raw_matrix)
 327               		.loc 1 215 18 is_stmt 0 view .LVU87
 328 001c C12C      		mov r12,__zero_reg__
 329               	.LBE49:
 211:quantum/matrix.c ****     bool changed = false;
 330               		.loc 1 211 10 view .LVU88
 331 001e D12C      		mov r13,__zero_reg__
 332               	.LBB80:
 333               	.LBB50:
 334               	.LBB51:
 335               	.LBB52:
 336               	.LBB53:
 337               	.LBB54:
 338               	.LBB55:
  37:quantum/matrix.c ****         writePinLow(pin);
 339               		.loc 1 37 9 view .LVU89
 340 0020 EE24      		clr r14
 341 0022 E394      		inc r14
 342 0024 F12C      		mov r15,__zero_reg__
 343               	.LVL24:
 344               	.L10:
  37:quantum/matrix.c ****         writePinLow(pin);
 345               		.loc 1 37 9 view .LVU90
 346               	.LBE55:
 347               	.LBE54:
 348               	.LBE53:
 349               	.LBE52:
 350               	.LBE51:
 351               	.LBE50:
 216:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 352               		.loc 1 216 9 is_stmt 1 view .LVU91
 353               	.LBB77:
 354               	.LBI50:
 100:quantum/matrix.c ****     // Start with a clear matrix row
 355               		.loc 1 100 13 view .LVU92
 356               	.LBB74:
 102:quantum/matrix.c **** 
 357               		.loc 1 102 5 view .LVU93
 105:quantum/matrix.c ****     matrix_output_select_delay();
 358               		.loc 1 105 5 view .LVU94
 359               	.LBB65:
 360               	.LBI52:
  83:quantum/matrix.c **** 
 361               		.loc 1 83 13 view .LVU95
 362               	.LBB63:
  83:quantum/matrix.c **** 
 363               		.loc 1 83 39 view .LVU96
 364 0026 F801      		movw r30,r16
 365 0028 8191      		ld r24,Z+
 366 002a 8F01      		movw r16,r30
 367               	.LVL25:
 368               	.LBB61:
 369               	.LBI54:
  35:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
 370               		.loc 1 35 20 view .LVU97
 371               	.LBE61:
 372               	.LBE63:
 373               	.LBE65:
 374               	.LBE74:
 375               	.LBE77:
 376               	.LBE80:
  36:quantum/matrix.c ****         setPinOutput(pin);
 377               		.loc 1 36 5 view .LVU98
 378               	.LBB81:
 379               	.LBB78:
 380               	.LBB75:
 381               	.LBB66:
 382               	.LBB64:
 383               	.LBB62:
 384               	.LBB60:
  36:quantum/matrix.c ****         setPinOutput(pin);
 385               		.loc 1 36 5 view .LVU99
 386               	.LBB56:
 387               	.LBI56:
  48:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** {
 388               		.loc 2 48 27 view .LVU100
 389               	.LBB57:
  50:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     return 1;
 390               		.loc 2 50 5 view .LVU101
 391               	/* #APP */
 392               	 ;  50 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h" 1
 393 002c F894      		cli
 394               	 ;  0 "" 2
  51:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** }
 395               		.loc 2 51 5 view .LVU102
 396               	.LVL26:
  51:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** }
 397               		.loc 2 51 5 is_stmt 0 view .LVU103
 398               	/* #NOAPP */
 399               	.LBE57:
 400               	.LBE56:
  36:quantum/matrix.c ****         setPinOutput(pin);
 401               		.loc 1 36 5 is_stmt 1 view .LVU104
  37:quantum/matrix.c ****         writePinLow(pin);
 402               		.loc 1 37 9 view .LVU105
 403 002e E82F      		mov r30,r24
 404 0030 E295      		swap r30
 405 0032 EF70      		andi r30,lo8(15)
 406 0034 F0E0      		ldi r31,0
 407 0036 21A1      		ldd r18,Z+33
 408 0038 8F70      		andi r24,lo8(15)
 409               	.LVL27:
  37:quantum/matrix.c ****         writePinLow(pin);
 410               		.loc 1 37 9 is_stmt 0 view .LVU106
 411 003a A701      		movw r20,r14
 412 003c 00C0      		rjmp 2f
 413               		1:
 414 003e 440F      		lsl r20
 415 0040 551F      		rol r21
 416               		2:
 417 0042 8A95      		dec r24
 418 0044 02F4      		brpl 1b
 419 0046 CA01      		movw r24,r20
 420 0048 922F      		mov r25,r18
 421 004a 982B      		or r25,r24
 422 004c 91A3      		std Z+33,r25
 423               	.LVL28:
  38:quantum/matrix.c ****     }
 424               		.loc 1 38 9 is_stmt 1 view .LVU107
 425 004e 92A1      		ldd r25,Z+34
 426 0050 8095      		com r24
 427 0052 8923      		and r24,r25
 428 0054 82A3      		std Z+34,r24
  36:quantum/matrix.c ****         setPinOutput(pin);
 429               		.loc 1 36 5 view .LVU108
 430               	.LVL29:
  36:quantum/matrix.c ****         setPinOutput(pin);
 431               		.loc 1 36 5 view .LVU109
 432               	.LBB58:
 433               	.LBI58:
  54:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h **** {
 434               		.loc 2 54 24 view .LVU110
 435               	.LBB59:
  56:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 436               		.loc 2 56 5 view .LVU111
 437               	/* #APP */
 438               	 ;  56 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h" 1
 439 0056 7894      		sei
 440               	 ;  0 "" 2
  57:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/atomic.h ****     (void)__s;
 441               		.loc 2 57 5 view .LVU112
 442               		.loc 2 58 5 view .LVU113
 443               	.LVL30:
 444               		.loc 2 58 5 is_stmt 0 view .LVU114
 445               	/* #NOAPP */
 446               	.LBE59:
 447               	.LBE58:
 448               	.LBE60:
 449               	.LBE62:
 450               	.LBE64:
 451               	.LBE66:
 106:quantum/matrix.c **** 
 452               		.loc 1 106 5 is_stmt 1 view .LVU115
 453 0058 0E94 0000 		call matrix_output_select_delay
 454               	.LVL31:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 455               		.loc 1 109 5 view .LVU116
 456               	.LBB67:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 457               		.loc 1 109 10 view .LVU117
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 458               		.loc 1 109 33 view .LVU118
 459 005c E0E0      		ldi r30,lo8(col_pins)
 460 005e F0E0      		ldi r31,hi8(col_pins)
 461               	.LBE67:
 106:quantum/matrix.c **** 
 462               		.loc 1 106 5 is_stmt 0 view .LVU119
 463 0060 30E0      		ldi r19,0
 464 0062 20E0      		ldi r18,0
 102:quantum/matrix.c **** 
 465               		.loc 1 102 18 view .LVU120
 466 0064 B12C      		mov r11,__zero_reg__
 467 0066 A12C      		mov r10,__zero_reg__
 468               	.LVL32:
 469               	.L7:
 470               	.LBB70:
 471               	.LBB68:
 111:quantum/matrix.c **** 
 472               		.loc 1 111 9 is_stmt 1 view .LVU121
 111:quantum/matrix.c **** 
 473               		.loc 1 111 29 is_stmt 0 view .LVU122
 474 0068 4191      		ld r20,Z+
 475 006a A42F      		mov r26,r20
 476 006c A295      		swap r26
 477 006e AF70      		andi r26,lo8(15)
 478 0070 B0E0      		ldi r27,0
 479 0072 9096      		adiw r26,32
 480 0074 8C91      		ld r24,X
 481               	.LVL33:
 114:quantum/matrix.c ****     }
 482               		.loc 1 114 9 is_stmt 1 view .LVU123
 111:quantum/matrix.c **** 
 483               		.loc 1 111 29 is_stmt 0 view .LVU124
 484 0076 90E0      		ldi r25,0
 485 0078 4F70      		andi r20,lo8(15)
 486               	.LVL34:
 111:quantum/matrix.c **** 
 487               		.loc 1 111 29 view .LVU125
 488 007a 00C0      		rjmp 2f
 489               		1:
 490 007c 9595      		asr r25
 491 007e 8795      		ror r24
 492               		2:
 493 0080 4A95      		dec r20
 494 0082 02F4      		brpl 1b
 495               	.LVL35:
 114:quantum/matrix.c ****     }
 496               		.loc 1 114 44 view .LVU126
 497 0084 80FD      		sbrc r24,0
 498 0086 00C0      		rjmp .L11
 499 0088 C701      		movw r24,r14
 500 008a 022E      		mov r0,r18
 501 008c 00C0      		rjmp 2f
 502               		1:
 503 008e 880F      		lsl r24
 504 0090 991F      		rol r25
 505               		2:
 506 0092 0A94      		dec r0
 507 0094 02F4      		brpl 1b
 508               	.L6:
 114:quantum/matrix.c ****     }
 509               		.loc 1 114 27 view .LVU127
 510 0096 A82A      		or r10,r24
 511               	.LVL36:
 114:quantum/matrix.c ****     }
 512               		.loc 1 114 27 view .LVU128
 513 0098 B92A      		or r11,r25
 514               	.LVL37:
 114:quantum/matrix.c ****     }
 515               		.loc 1 114 27 view .LVU129
 516               	.LBE68:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 517               		.loc 1 109 58 is_stmt 1 view .LVU130
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 518               		.loc 1 109 33 view .LVU131
 519 009a 2F5F      		subi r18,-1
 520 009c 3F4F      		sbci r19,-1
 521               	.LVL38:
 109:quantum/matrix.c ****         // Select the col pin to read (active low)
 522               		.loc 1 109 5 is_stmt 0 view .LVU132
 523 009e 2F30      		cpi r18,15
 524 00a0 3105      		cpc r19,__zero_reg__
 525 00a2 01F4      		brne .L7
 526               	.LBE70:
 118:quantum/matrix.c ****     if (current_row + 1 < MATRIX_ROWS) {
 527               		.loc 1 118 5 is_stmt 1 view .LVU133
 528               	.LVL39:
 529               	.LBB71:
 530               	.LBI71:
  85:quantum/matrix.c **** 
 531               		.loc 1 85 13 view .LVU134
 532               	.LBB72:
  85:quantum/matrix.c **** 
 533               		.loc 1 85 41 view .LVU135
 534 00a4 F801      		movw r30,r16
 535 00a6 3197      		sbiw r30,1
 536 00a8 8081      		ld r24,Z
 537 00aa 0E94 0000 		call setPinInputHigh_atomic
 538               	.LVL40:
  85:quantum/matrix.c **** 
 539               		.loc 1 85 41 is_stmt 0 view .LVU136
 540               	.LBE72:
 541               	.LBE71:
 119:quantum/matrix.c ****         matrix_output_unselect_delay();  // wait for row signal to go HIGH
 542               		.loc 1 119 5 is_stmt 1 view .LVU137
 119:quantum/matrix.c ****         matrix_output_unselect_delay();  // wait for row signal to go HIGH
 543               		.loc 1 119 8 is_stmt 0 view .LVU138
 544 00ae 54E0      		ldi r21,lo8(4)
 545 00b0 C512      		cpse r12,r21
 120:quantum/matrix.c ****     }
 546               		.loc 1 120 9 is_stmt 1 view .LVU139
 547 00b2 0E94 0000 		call matrix_output_unselect_delay
 548               	.LVL41:
 549               	.L8:
 124:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
 550               		.loc 1 124 5 view .LVU140
 124:quantum/matrix.c ****         current_matrix[current_row] = current_row_value;
 551               		.loc 1 124 8 is_stmt 0 view .LVU141
 552 00b6 8881      		ld r24,Y
 553 00b8 9981      		ldd r25,Y+1
 554 00ba A816      		cp r10,r24
 555 00bc B906      		cpc r11,r25
 556 00be 01F0      		breq .L12
 125:quantum/matrix.c ****         return true;
 557               		.loc 1 125 9 is_stmt 1 view .LVU142
 125:quantum/matrix.c ****         return true;
 558               		.loc 1 125 37 is_stmt 0 view .LVU143
 559 00c0 B982      		std Y+1,r11
 560 00c2 A882      		st Y,r10
 126:quantum/matrix.c ****     }
 561               		.loc 1 126 9 is_stmt 1 view .LVU144
 126:quantum/matrix.c ****     }
 562               		.loc 1 126 16 is_stmt 0 view .LVU145
 563 00c4 81E0      		ldi r24,lo8(1)
 564               	.L9:
 565               	.LVL42:
 126:quantum/matrix.c ****     }
 566               		.loc 1 126 16 view .LVU146
 567               	.LBE75:
 568               	.LBE78:
 569               		.loc 1 216 17 view .LVU147
 570 00c6 D82A      		or r13,r24
 571               	.LVL43:
 215:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 572               		.loc 1 215 62 is_stmt 1 view .LVU148
 215:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 573               		.loc 1 215 73 is_stmt 0 view .LVU149
 574 00c8 C394      		inc r12
 575               	.LVL44:
 215:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 576               		.loc 1 215 35 is_stmt 1 view .LVU150
 577 00ca 2296      		adiw r28,2
 215:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 578               		.loc 1 215 5 is_stmt 0 view .LVU151
 579 00cc 85E0      		ldi r24,lo8(5)
 580 00ce C812      		cpse r12,r24
 581 00d0 00C0      		rjmp .L10
 582               	.LVL45:
 215:quantum/matrix.c ****         changed |= read_cols_on_row(raw_matrix, current_row);
 583               		.loc 1 215 5 view .LVU152
 584               	.LBE81:
 217:quantum/matrix.c ****     }
 218:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 219:quantum/matrix.c ****     // Set col, read rows
 220:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 221:quantum/matrix.c ****         changed |= read_rows_on_col(raw_matrix, current_col);
 222:quantum/matrix.c ****     }
 223:quantum/matrix.c **** #endif
 224:quantum/matrix.c **** 
 225:quantum/matrix.c ****     debounce(raw_matrix, matrix, MATRIX_ROWS, changed);
 585               		.loc 1 225 5 is_stmt 1 view .LVU153
 586 00d2 2D2D      		mov r18,r13
 587 00d4 45E0      		ldi r20,lo8(5)
 588 00d6 60E0      		ldi r22,lo8(matrix)
 589 00d8 70E0      		ldi r23,hi8(matrix)
 590 00da 80E0      		ldi r24,lo8(raw_matrix)
 591 00dc 90E0      		ldi r25,hi8(raw_matrix)
 592 00de 0E94 0000 		call debounce
 593               	.LVL46:
 226:quantum/matrix.c **** 
 227:quantum/matrix.c ****     matrix_scan_quantum();
 594               		.loc 1 227 5 view .LVU154
 595 00e2 0E94 0000 		call matrix_scan_quantum
 596               	.LVL47:
 228:quantum/matrix.c ****     return (uint8_t)changed;
 597               		.loc 1 228 5 view .LVU155
 229:quantum/matrix.c **** }
 598               		.loc 1 229 1 is_stmt 0 view .LVU156
 599 00e6 8D2D      		mov r24,r13
 600               	/* epilogue start */
 601 00e8 DF91      		pop r29
 602 00ea CF91      		pop r28
 603 00ec 1F91      		pop r17
 604 00ee 0F91      		pop r16
 605 00f0 FF90      		pop r15
 606 00f2 EF90      		pop r14
 607 00f4 DF90      		pop r13
 608               	.LVL48:
 609               		.loc 1 229 1 view .LVU157
 610 00f6 CF90      		pop r12
 611 00f8 BF90      		pop r11
 612 00fa AF90      		pop r10
 613 00fc 0895      		ret
 614               	.LVL49:
 615               	.L11:
 616               	.LBB82:
 617               	.LBB79:
 618               	.LBB76:
 619               	.LBB73:
 620               	.LBB69:
 114:quantum/matrix.c ****     }
 621               		.loc 1 114 44 view .LVU158
 622 00fe 90E0      		ldi r25,0
 623 0100 80E0      		ldi r24,0
 624 0102 00C0      		rjmp .L6
 625               	.LVL50:
 626               	.L12:
 114:quantum/matrix.c ****     }
 627               		.loc 1 114 44 view .LVU159
 628               	.LBE69:
 629               	.LBE73:
 128:quantum/matrix.c **** }
 630               		.loc 1 128 12 view .LVU160
 631 0104 80E0      		ldi r24,0
 632 0106 00C0      		rjmp .L9
 633               	.LBE76:
 634               	.LBE79:
 635               	.LBE82:
 636               		.cfi_endproc
 637               	.LFE125:
 639               		.section	.rodata.col_pins,"a"
 642               	col_pins:
 643 0000 F0        		.byte	-16
 644 0001 F1        		.byte	-15
 645 0002 C6        		.byte	-58
 646 0003 67        		.byte	103
 647 0004 66        		.byte	102
 648 0005 37        		.byte	55
 649 0006 94        		.byte	-108
 650 0007 31        		.byte	49
 651 0008 30        		.byte	48
 652 0009 35        		.byte	53
 653 000a 34        		.byte	52
 654 000b 97        		.byte	-105
 655 000c 96        		.byte	-106
 656 000d 33        		.byte	51
 657 000e F4        		.byte	-12
 658               		.section	.rodata.row_pins,"a"
 661               	row_pins:
 662 0000 90        		.byte	-112
 663 0001 91        		.byte	-111
 664 0002 92        		.byte	-110
 665 0003 93        		.byte	-109
 666 0004 95        		.byte	-107
 667               		.text
 668               	.Letext0:
 669               		.file 3 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/stdint.h"
 670               		.file 4 "quantum/matrix.h"
 671               		.file 5 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/lib/avr-gcc/8/gcc/avr/8.4.0/include/stddef.h"
 672               		.file 6 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 673               		.file 7 "tmk_core/common/action.h"
 674               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 675               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 676               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 677               		.file 11 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/stdio.h"
 678               		.file 12 "tmk_core/common/report.h"
 679               		.file 13 "tmk_core/common/host.h"
 680               		.file 14 "tmk_core/common/debug.h"
 681               		.file 15 "quantum/keycode_config.h"
 682               		.file 16 "quantum/keymap.h"
 683               		.file 17 "./quantum/color.h"
 684               		.file 18 "quantum/rgblight.h"
 685               		.file 19 "tmk_core/common/action_layer.h"
 686               		.file 20 "tmk_core/common/timer.h"
 687               		.file 21 "tmk_core/common/avr/gpio.h"
 688               		.file 22 "tmk_core/common/action_util.h"
 689               		.file 23 "quantum/send_string.h"
 690               		.file 24 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/stdlib.h"
 691               		.file 25 "quantum/process_keycode/process_unicode_common.h"
 692               		.file 26 "quantum/process_keycode/process_unicodemap.h"
 693               		.file 27 "quantum/process_keycode/process_tap_dance.h"
 694               		.file 28 "quantum/debounce.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:4      *ABS*:000000000000003f __SREG__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:12     .text.setPinInputHigh_atomic:0000000000000000 setPinInputHigh_atomic
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:96     .text.matrix_init:0000000000000000 matrix_init
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:642    .rodata.col_pins:0000000000000000 col_pins
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:269    .text.matrix_scan:0000000000000000 matrix_scan
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//cco0X5cp.s:661    .rodata.row_pins:0000000000000000 row_pins

UNDEFINED SYMBOLS
raw_matrix
matrix
debounce_init
matrix_init_quantum
matrix_output_select_delay
matrix_output_unselect_delay
debounce
matrix_scan_quantum
__do_copy_data
