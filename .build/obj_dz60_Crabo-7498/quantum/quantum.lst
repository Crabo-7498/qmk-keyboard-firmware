   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LVL0:
  14               	.LFB117:
  15               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** 
  19:quantum/quantum.c **** #ifdef BLUETOOTH_ENABLE
  20:quantum/quantum.c **** #    include "outputselect.h"
  21:quantum/quantum.c **** #endif
  22:quantum/quantum.c **** 
  23:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
  24:quantum/quantum.c **** #    include "backlight.h"
  25:quantum/quantum.c **** #endif
  26:quantum/quantum.c **** 
  27:quantum/quantum.c **** #ifdef API_ENABLE
  28:quantum/quantum.c **** #    include "api.h"
  29:quantum/quantum.c **** #endif
  30:quantum/quantum.c **** 
  31:quantum/quantum.c **** #ifdef MIDI_ENABLE
  32:quantum/quantum.c **** #    include "process_midi.h"
  33:quantum/quantum.c **** #endif
  34:quantum/quantum.c **** 
  35:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
  36:quantum/quantum.c **** #    include "velocikey.h"
  37:quantum/quantum.c **** #endif
  38:quantum/quantum.c **** 
  39:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
  40:quantum/quantum.c **** #    include "haptic.h"
  41:quantum/quantum.c **** #endif
  42:quantum/quantum.c **** 
  43:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  44:quantum/quantum.c **** #    ifndef GOODBYE_SONG
  45:quantum/quantum.c **** #        define GOODBYE_SONG SONG(GOODBYE_SOUND)
  46:quantum/quantum.c **** #    endif
  47:quantum/quantum.c **** float goodbye_song[][2] = GOODBYE_SONG;
  48:quantum/quantum.c **** #    ifdef DEFAULT_LAYER_SONGS
  49:quantum/quantum.c **** float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  50:quantum/quantum.c **** #    endif
  51:quantum/quantum.c **** #    ifdef SENDSTRING_BELL
  52:quantum/quantum.c **** float bell_song[][2] = SONG(TERMINAL_SOUND);
  53:quantum/quantum.c **** #    endif
  54:quantum/quantum.c **** #endif
  55:quantum/quantum.c **** 
  56:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
  57:quantum/quantum.c **** #    include "process_auto_shift.h"
  58:quantum/quantum.c **** #endif
  59:quantum/quantum.c **** 
  60:quantum/quantum.c **** static void do_code16(uint16_t code, void (*f)(uint8_t)) {
  16               		.loc 1 60 58 view -0
  17               		.cfi_startproc
  18               		.loc 1 60 58 is_stmt 0 view .LVU1
  19 0000 CF93      		push r28
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 28, -2
  23 0002 DF93      		push r29
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 29, -3
  27               	/* prologue: function */
  28               	/* frame size = 0 */
  29               	/* stack size = 2 */
  30               	.L__stack_usage = 2
  61:quantum/quantum.c ****     switch (code) {
  31               		.loc 1 61 5 is_stmt 1 view .LVU2
  32 0004 9C01      		movw r18,r24
  33 0006 3A95      		dec r19
  34 0008 2115      		cp r18,__zero_reg__
  35 000a 3F41      		sbci r19,31
  36 000c 00F4      		brsh .L1
  62:quantum/quantum.c ****         case QK_MODS ... QK_MODS_MAX:
  63:quantum/quantum.c ****             break;
  37               		.loc 1 63 13 view .LVU3
  64:quantum/quantum.c ****         default:
  65:quantum/quantum.c ****             return;
  66:quantum/quantum.c ****     }
  67:quantum/quantum.c **** 
  68:quantum/quantum.c ****     uint8_t mods_to_send = 0;
  38               		.loc 1 68 5 view .LVU4
  39               	.LVL1:
  69:quantum/quantum.c **** 
  70:quantum/quantum.c ****     if (code & QK_RMODS_MIN) {  // Right mod flag is set
  40               		.loc 1 70 5 view .LVU5
  41 000e EC01      		movw r28,r24
  42 0010 CC27      		clr r28
  43 0012 D170      		andi r29,1
  44 0014 DC01      		movw r26,r24
  45 0016 AA27      		clr r26
  46 0018 B270      		andi r27,2
  47 001a AC01      		movw r20,r24
  48 001c 4427      		clr r20
  49 001e 5470      		andi r21,4
  50 0020 9C01      		movw r18,r24
  51 0022 2227      		clr r18
  52 0024 3870      		andi r19,8
  53               		.loc 1 70 8 is_stmt 0 view .LVU6
  54 0026 94FF      		sbrs r25,4
  55 0028 00C0      		rjmp .L3
  71:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_RCTL);
  56               		.loc 1 71 9 is_stmt 1 view .LVU7
  57               		.loc 1 71 42 is_stmt 0 view .LVU8
  58 002a 80E1      		ldi r24,lo8(16)
  59               	.LVL2:
  60               		.loc 1 71 12 view .LVU9
  61 002c CD2B      		or r28,r29
  62 002e 01F4      		brne .L4
  68:quantum/quantum.c **** 
  63               		.loc 1 68 13 view .LVU10
  64 0030 80E0      		ldi r24,0
  65               	.L4:
  66               	.LVL3:
  72:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_RSFT);
  67               		.loc 1 72 9 is_stmt 1 view .LVU11
  68               		.loc 1 72 12 is_stmt 0 view .LVU12
  69 0032 AB2B      		or r26,r27
  70 0034 01F0      		breq .L5
  71               		.loc 1 72 29 is_stmt 1 discriminator 1 view .LVU13
  72               		.loc 1 72 42 is_stmt 0 discriminator 1 view .LVU14
  73 0036 8062      		ori r24,lo8(32)
  74               	.LVL4:
  75               	.L5:
  73:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_RALT);
  76               		.loc 1 73 9 is_stmt 1 view .LVU15
  77               		.loc 1 73 12 is_stmt 0 view .LVU16
  78 0038 452B      		or r20,r21
  79 003a 01F0      		breq .L6
  80               		.loc 1 73 29 is_stmt 1 discriminator 1 view .LVU17
  81               		.loc 1 73 42 is_stmt 0 discriminator 1 view .LVU18
  82 003c 8064      		ori r24,lo8(64)
  83               	.LVL5:
  84               	.L6:
  74:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_RGUI);
  85               		.loc 1 74 9 is_stmt 1 view .LVU19
  86               		.loc 1 74 12 is_stmt 0 view .LVU20
  87 003e 232B      		or r18,r19
  88 0040 01F0      		breq .L7
  89               		.loc 1 74 29 is_stmt 1 discriminator 1 view .LVU21
  90               		.loc 1 74 42 is_stmt 0 discriminator 1 view .LVU22
  91 0042 8068      		ori r24,lo8(-128)
  92               	.LVL6:
  93               	.L7:
  75:quantum/quantum.c ****     } else {
  76:quantum/quantum.c ****         if (code & QK_LCTL) mods_to_send |= MOD_BIT(KC_LCTL);
  77:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_LSFT);
  78:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
  79:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
  80:quantum/quantum.c ****     }
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****     f(mods_to_send);
  94               		.loc 1 82 5 is_stmt 1 view .LVU23
  95 0044 FB01      		movw r30,r22
  96               	/* epilogue start */
  83:quantum/quantum.c **** }
  97               		.loc 1 83 1 is_stmt 0 view .LVU24
  98 0046 DF91      		pop r29
  99 0048 CF91      		pop r28
  82:quantum/quantum.c **** }
 100               		.loc 1 82 5 view .LVU25
 101 004a 0994      		ijmp
 102               	.LVL7:
 103               	.L3:
  76:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_LSFT);
 104               		.loc 1 76 9 is_stmt 1 view .LVU26
  76:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_LSFT);
 105               		.loc 1 76 12 is_stmt 0 view .LVU27
 106 004c 81E0      		ldi r24,lo8(1)
 107               	.LVL8:
  76:quantum/quantum.c ****         if (code & QK_LSFT) mods_to_send |= MOD_BIT(KC_LSFT);
 108               		.loc 1 76 12 view .LVU28
 109 004e CD2B      		or r28,r29
 110 0050 01F4      		brne .L8
 111 0052 80E0      		ldi r24,0
 112               	.L8:
 113               	.LVL9:
  77:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
 114               		.loc 1 77 9 is_stmt 1 view .LVU29
  77:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
 115               		.loc 1 77 12 is_stmt 0 view .LVU30
 116 0054 AB2B      		or r26,r27
 117 0056 01F0      		breq .L9
  77:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
 118               		.loc 1 77 29 is_stmt 1 discriminator 1 view .LVU31
  77:quantum/quantum.c ****         if (code & QK_LALT) mods_to_send |= MOD_BIT(KC_LALT);
 119               		.loc 1 77 42 is_stmt 0 discriminator 1 view .LVU32
 120 0058 8260      		ori r24,lo8(2)
 121               	.LVL10:
 122               	.L9:
  78:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
 123               		.loc 1 78 9 is_stmt 1 view .LVU33
  78:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
 124               		.loc 1 78 12 is_stmt 0 view .LVU34
 125 005a 452B      		or r20,r21
 126 005c 01F0      		breq .L10
  78:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
 127               		.loc 1 78 29 is_stmt 1 discriminator 1 view .LVU35
  78:quantum/quantum.c ****         if (code & QK_LGUI) mods_to_send |= MOD_BIT(KC_LGUI);
 128               		.loc 1 78 42 is_stmt 0 discriminator 1 view .LVU36
 129 005e 8460      		ori r24,lo8(4)
 130               	.LVL11:
 131               	.L10:
  79:quantum/quantum.c ****     }
 132               		.loc 1 79 9 is_stmt 1 view .LVU37
  79:quantum/quantum.c ****     }
 133               		.loc 1 79 12 is_stmt 0 view .LVU38
 134 0060 232B      		or r18,r19
 135 0062 01F0      		breq .L7
  79:quantum/quantum.c ****     }
 136               		.loc 1 79 29 is_stmt 1 discriminator 1 view .LVU39
  79:quantum/quantum.c ****     }
 137               		.loc 1 79 42 is_stmt 0 discriminator 1 view .LVU40
 138 0064 8860      		ori r24,lo8(8)
 139               	.LVL12:
  79:quantum/quantum.c ****     }
 140               		.loc 1 79 42 discriminator 1 view .LVU41
 141 0066 00C0      		rjmp .L7
 142               	.LVL13:
 143               	.L1:
 144               	/* epilogue start */
 145               		.loc 1 83 1 view .LVU42
 146 0068 DF91      		pop r29
 147 006a CF91      		pop r28
 148 006c 0895      		ret
 149               		.cfi_endproc
 150               	.LFE117:
 152               		.section	.text.register_code16,"ax",@progbits
 153               	.global	register_code16
 155               	register_code16:
 156               	.LVL14:
 157               	.LFB118:
  84:quantum/quantum.c **** 
  85:quantum/quantum.c **** void register_code16(uint16_t code) {
 158               		.loc 1 85 37 is_stmt 1 view -0
 159               		.cfi_startproc
 160               		.loc 1 85 37 is_stmt 0 view .LVU44
 161 0000 CF93      		push r28
 162               	.LCFI2:
 163               		.cfi_def_cfa_offset 3
 164               		.cfi_offset 28, -2
 165 0002 DF93      		push r29
 166               	.LCFI3:
 167               		.cfi_def_cfa_offset 4
 168               		.cfi_offset 29, -3
 169               	/* prologue: function */
 170               	/* frame size = 0 */
 171               	/* stack size = 2 */
 172               	.L__stack_usage = 2
 173 0004 EC01      		movw r28,r24
  86:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 174               		.loc 1 86 5 is_stmt 1 view .LVU45
 175               		.loc 1 86 9 is_stmt 0 view .LVU46
 176 0006 805E      		subi r24,-32
 177 0008 9109      		sbc r25,__zero_reg__
 178               	.LVL15:
 179               		.loc 1 86 8 view .LVU47
 180 000a 0897      		sbiw r24,8
 181 000c 00F0      		brlo .L31
  87:quantum/quantum.c ****         do_code16(code, register_mods);
  88:quantum/quantum.c ****     } else {
  89:quantum/quantum.c ****         do_code16(code, register_weak_mods);
 182               		.loc 1 89 9 discriminator 1 view .LVU48
 183 000e 60E0      		ldi r22,lo8(gs(register_weak_mods))
 184 0010 70E0      		ldi r23,hi8(gs(register_weak_mods))
  86:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 185               		.loc 1 86 22 discriminator 1 view .LVU49
 186 0012 2097      		sbiw r28,0
 187 0014 01F4      		brne .L34
 188               	.L31:
  87:quantum/quantum.c ****         do_code16(code, register_mods);
 189               		.loc 1 87 9 is_stmt 1 view .LVU50
 190 0016 60E0      		ldi r22,lo8(gs(register_mods))
 191 0018 70E0      		ldi r23,hi8(gs(register_mods))
 192               	.L34:
 193               		.loc 1 89 9 is_stmt 0 view .LVU51
 194 001a CE01      		movw r24,r28
 195 001c 0E94 0000 		call do_code16
 196               	.LVL16:
  90:quantum/quantum.c ****     }
  91:quantum/quantum.c ****     register_code(code);
 197               		.loc 1 91 5 is_stmt 1 view .LVU52
 198 0020 8C2F      		mov r24,r28
 199               	/* epilogue start */
  92:quantum/quantum.c **** }
 200               		.loc 1 92 1 is_stmt 0 view .LVU53
 201 0022 DF91      		pop r29
 202 0024 CF91      		pop r28
 203               	.LVL17:
  91:quantum/quantum.c **** }
 204               		.loc 1 91 5 view .LVU54
 205 0026 0C94 0000 		jmp register_code
 206               	.LVL18:
 207               		.cfi_endproc
 208               	.LFE118:
 210               		.section	.text.unregister_code16,"ax",@progbits
 211               	.global	unregister_code16
 213               	unregister_code16:
 214               	.LVL19:
 215               	.LFB119:
  93:quantum/quantum.c **** 
  94:quantum/quantum.c **** void unregister_code16(uint16_t code) {
 216               		.loc 1 94 39 is_stmt 1 view -0
 217               		.cfi_startproc
 218               		.loc 1 94 39 is_stmt 0 view .LVU56
 219 0000 CF93      		push r28
 220               	.LCFI4:
 221               		.cfi_def_cfa_offset 3
 222               		.cfi_offset 28, -2
 223 0002 DF93      		push r29
 224               	.LCFI5:
 225               		.cfi_def_cfa_offset 4
 226               		.cfi_offset 29, -3
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 2 */
 230               	.L__stack_usage = 2
 231 0004 EC01      		movw r28,r24
  95:quantum/quantum.c ****     unregister_code(code);
 232               		.loc 1 95 5 is_stmt 1 view .LVU57
 233 0006 0E94 0000 		call unregister_code
 234               	.LVL20:
  96:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 235               		.loc 1 96 5 view .LVU58
 236               		.loc 1 96 9 is_stmt 0 view .LVU59
 237 000a CE01      		movw r24,r28
 238 000c 805E      		subi r24,-32
 239 000e 9109      		sbc r25,__zero_reg__
 240               		.loc 1 96 8 view .LVU60
 241 0010 0897      		sbiw r24,8
 242 0012 00F0      		brlo .L36
  97:quantum/quantum.c ****         do_code16(code, unregister_mods);
  98:quantum/quantum.c ****     } else {
  99:quantum/quantum.c ****         do_code16(code, unregister_weak_mods);
 243               		.loc 1 99 9 discriminator 1 view .LVU61
 244 0014 60E0      		ldi r22,lo8(gs(unregister_weak_mods))
 245 0016 70E0      		ldi r23,hi8(gs(unregister_weak_mods))
  96:quantum/quantum.c ****     if (IS_MOD(code) || code == KC_NO) {
 246               		.loc 1 96 22 discriminator 1 view .LVU62
 247 0018 2097      		sbiw r28,0
 248 001a 01F4      		brne .L38
 249               	.L36:
  97:quantum/quantum.c ****         do_code16(code, unregister_mods);
 250               		.loc 1 97 9 is_stmt 1 view .LVU63
 251 001c 60E0      		ldi r22,lo8(gs(unregister_mods))
 252 001e 70E0      		ldi r23,hi8(gs(unregister_mods))
 253               	.L38:
 254               		.loc 1 99 9 is_stmt 0 view .LVU64
 255 0020 CE01      		movw r24,r28
 256               	/* epilogue start */
 100:quantum/quantum.c ****     }
 101:quantum/quantum.c **** }
 257               		.loc 1 101 1 view .LVU65
 258 0022 DF91      		pop r29
 259 0024 CF91      		pop r28
 260               	.LVL21:
  99:quantum/quantum.c ****     }
 261               		.loc 1 99 9 view .LVU66
 262 0026 0C94 0000 		jmp do_code16
 263               	.LVL22:
  99:quantum/quantum.c ****     }
 264               		.loc 1 99 9 view .LVU67
 265               		.cfi_endproc
 266               	.LFE119:
 268               		.section	.text.tap_code16,"ax",@progbits
 269               	.global	tap_code16
 271               	tap_code16:
 272               	.LVL23:
 273               	.LFB120:
 102:quantum/quantum.c **** 
 103:quantum/quantum.c **** void tap_code16(uint16_t code) {
 274               		.loc 1 103 32 is_stmt 1 view -0
 275               		.cfi_startproc
 276               		.loc 1 103 32 is_stmt 0 view .LVU69
 277 0000 CF93      		push r28
 278               	.LCFI6:
 279               		.cfi_def_cfa_offset 3
 280               		.cfi_offset 28, -2
 281 0002 DF93      		push r29
 282               	.LCFI7:
 283               		.cfi_def_cfa_offset 4
 284               		.cfi_offset 29, -3
 285               	/* prologue: function */
 286               	/* frame size = 0 */
 287               	/* stack size = 2 */
 288               	.L__stack_usage = 2
 289 0004 EC01      		movw r28,r24
 104:quantum/quantum.c ****     register_code16(code);
 290               		.loc 1 104 5 is_stmt 1 view .LVU70
 291 0006 0E94 0000 		call register_code16
 292               	.LVL24:
 105:quantum/quantum.c **** #if TAP_CODE_DELAY > 0
 106:quantum/quantum.c ****     wait_ms(TAP_CODE_DELAY);
 107:quantum/quantum.c **** #endif
 108:quantum/quantum.c ****     unregister_code16(code);
 293               		.loc 1 108 5 view .LVU71
 294 000a CE01      		movw r24,r28
 295               	/* epilogue start */
 109:quantum/quantum.c **** }
 296               		.loc 1 109 1 is_stmt 0 view .LVU72
 297 000c DF91      		pop r29
 298 000e CF91      		pop r28
 299               	.LVL25:
 108:quantum/quantum.c **** }
 300               		.loc 1 108 5 view .LVU73
 301 0010 0C94 0000 		jmp unregister_code16
 302               	.LVL26:
 108:quantum/quantum.c **** }
 303               		.loc 1 108 5 view .LVU74
 304               		.cfi_endproc
 305               	.LFE120:
 307               		.section	.text.process_action_kb,"ax",@progbits
 308               		.weak	process_action_kb
 310               	process_action_kb:
 311               	.LVL27:
 312               	.LFB121:
 110:quantum/quantum.c **** 
 111:quantum/quantum.c **** __attribute__((weak)) bool process_action_kb(keyrecord_t *record) { return true; }
 313               		.loc 1 111 67 is_stmt 1 view -0
 314               		.cfi_startproc
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 0 */
 318               	.L__stack_usage = 0
 319               		.loc 1 111 69 view .LVU76
 320               		.loc 1 111 1 is_stmt 0 view .LVU77
 321 0000 81E0      		ldi r24,lo8(1)
 322               	.LVL28:
 323               	/* epilogue start */
 324               		.loc 1 111 1 view .LVU78
 325 0002 0895      		ret
 326               		.cfi_endproc
 327               	.LFE121:
 329               		.section	.text.process_record_user,"ax",@progbits
 330               		.weak	process_record_user
 332               	process_record_user:
 333               	.LVL29:
 334               	.LFB123:
 112:quantum/quantum.c **** 
 113:quantum/quantum.c **** __attribute__((weak)) bool process_record_kb(uint16_t keycode, keyrecord_t *record) { return proces
 114:quantum/quantum.c **** 
 115:quantum/quantum.c **** __attribute__((weak)) bool process_record_user(uint16_t keycode, keyrecord_t *record) { return true
 335               		.loc 1 115 87 is_stmt 1 view -0
 336               		.cfi_startproc
 337               	/* prologue: function */
 338               	/* frame size = 0 */
 339               	/* stack size = 0 */
 340               	.L__stack_usage = 0
 341               		.loc 1 115 89 view .LVU80
 342               		.loc 1 115 1 is_stmt 0 view .LVU81
 343 0000 81E0      		ldi r24,lo8(1)
 344               	.LVL30:
 345               	/* epilogue start */
 346               		.loc 1 115 1 view .LVU82
 347 0002 0895      		ret
 348               		.cfi_endproc
 349               	.LFE123:
 351               		.section	.text.process_record_kb,"ax",@progbits
 352               		.weak	process_record_kb
 354               	process_record_kb:
 355               	.LVL31:
 356               	.LFB122:
 113:quantum/quantum.c **** 
 357               		.loc 1 113 85 is_stmt 1 view -0
 358               		.cfi_startproc
 359               	/* prologue: function */
 360               	/* frame size = 0 */
 361               	/* stack size = 0 */
 362               	.L__stack_usage = 0
 113:quantum/quantum.c **** 
 363               		.loc 1 113 87 view .LVU84
 113:quantum/quantum.c **** 
 364               		.loc 1 113 94 is_stmt 0 view .LVU85
 365 0000 0C94 0000 		jmp process_record_user
 366               	.LVL32:
 113:quantum/quantum.c **** 
 367               		.loc 1 113 94 view .LVU86
 368               		.cfi_endproc
 369               	.LFE122:
 371               		.section	.text.post_process_record_user,"ax",@progbits
 372               		.weak	post_process_record_user
 374               	post_process_record_user:
 375               	.LVL33:
 376               	.LFB125:
 116:quantum/quantum.c **** 
 117:quantum/quantum.c **** __attribute__((weak)) void post_process_record_kb(uint16_t keycode, keyrecord_t *record) { post_pro
 118:quantum/quantum.c **** 
 119:quantum/quantum.c **** __attribute__((weak)) void post_process_record_user(uint16_t keycode, keyrecord_t *record) {}
 377               		.loc 1 119 92 is_stmt 1 view -0
 378               		.cfi_startproc
 379               	/* prologue: function */
 380               	/* frame size = 0 */
 381               	/* stack size = 0 */
 382               	.L__stack_usage = 0
 383               		.loc 1 119 93 view .LVU88
 384               	/* epilogue start */
 385               		.loc 1 119 1 is_stmt 0 view .LVU89
 386 0000 0895      		ret
 387               		.cfi_endproc
 388               	.LFE125:
 390               		.section	.text.post_process_record_kb,"ax",@progbits
 391               		.weak	post_process_record_kb
 393               	post_process_record_kb:
 394               	.LVL34:
 395               	.LFB124:
 117:quantum/quantum.c **** 
 396               		.loc 1 117 90 is_stmt 1 view -0
 397               		.cfi_startproc
 398               	/* prologue: function */
 399               	/* frame size = 0 */
 400               	/* stack size = 0 */
 401               	.L__stack_usage = 0
 117:quantum/quantum.c **** 
 402               		.loc 1 117 92 view .LVU91
 403 0000 0C94 0000 		jmp post_process_record_user
 404               	.LVL35:
 117:quantum/quantum.c **** 
 405               		.loc 1 117 92 is_stmt 0 view .LVU92
 406               		.cfi_endproc
 407               	.LFE124:
 409               		.section	.text.get_event_keycode,"ax",@progbits
 410               	.global	get_event_keycode
 412               	get_event_keycode:
 413               	.LVL36:
 414               	.LFB128:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void reset_keyboard(void) {
 122:quantum/quantum.c ****     clear_keyboard();
 123:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 124:quantum/quantum.c ****     process_midi_all_notes_off();
 125:quantum/quantum.c **** #endif
 126:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 127:quantum/quantum.c **** #    ifndef NO_MUSIC_MODE
 128:quantum/quantum.c ****     music_all_notes_off();
 129:quantum/quantum.c **** #    endif
 130:quantum/quantum.c ****     uint16_t timer_start = timer_read();
 131:quantum/quantum.c ****     PLAY_SONG(goodbye_song);
 132:quantum/quantum.c ****     shutdown_user();
 133:quantum/quantum.c ****     while (timer_elapsed(timer_start) < 250) wait_ms(1);
 134:quantum/quantum.c ****     stop_all_notes();
 135:quantum/quantum.c **** #else
 136:quantum/quantum.c ****     shutdown_user();
 137:quantum/quantum.c ****     wait_ms(250);
 138:quantum/quantum.c **** #endif
 139:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 140:quantum/quantum.c ****     haptic_shutdown();
 141:quantum/quantum.c **** #endif
 142:quantum/quantum.c ****     bootloader_jump();
 143:quantum/quantum.c **** }
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** /* Convert record into usable keycode via the contained event. */
 146:quantum/quantum.c **** uint16_t get_record_keycode(keyrecord_t *record, bool update_layer_cache) { return get_event_keycod
 147:quantum/quantum.c **** 
 148:quantum/quantum.c **** /* Convert event into usable keycode. Checks the layer cache to ensure that it
 149:quantum/quantum.c ****  * retains the correct keycode after a layer change, if the key is still pressed.
 150:quantum/quantum.c ****  * "update_layer_cache" is to ensure that it only updates the layer cache when
 151:quantum/quantum.c ****  * appropriate, otherwise, it will update it and cause layer tap (and other keys)
 152:quantum/quantum.c ****  * from triggering properly.
 153:quantum/quantum.c ****  */
 154:quantum/quantum.c **** uint16_t get_event_keycode(keyevent_t event, bool update_layer_cache) {
 415               		.loc 1 154 71 is_stmt 1 view -0
 416               		.cfi_startproc
 417               		.loc 1 154 71 is_stmt 0 view .LVU94
 418 0000 1F93      		push r17
 419               	.LCFI8:
 420               		.cfi_def_cfa_offset 3
 421               		.cfi_offset 17, -2
 422 0002 CF93      		push r28
 423               	.LCFI9:
 424               		.cfi_def_cfa_offset 4
 425               		.cfi_offset 28, -3
 426 0004 DF93      		push r29
 427               	.LCFI10:
 428               		.cfi_def_cfa_offset 5
 429               		.cfi_offset 29, -4
 430 0006 00D0      		rcall .
 431 0008 00D0      		rcall .
 432 000a 0F92      		push __tmp_reg__
 433               	.LCFI11:
 434               		.cfi_def_cfa_offset 10
 435 000c CDB7      		in r28,__SP_L__
 436 000e DEB7      		in r29,__SP_H__
 437               	.LCFI12:
 438               		.cfi_def_cfa_register 28
 439               	/* prologue: function */
 440               	/* frame size = 5 */
 441               	/* stack size = 8 */
 442               	.L__stack_usage = 8
 443 0010 4983      		std Y+1,r20
 444 0012 5A83      		std Y+2,r21
 445 0014 6B83      		std Y+3,r22
 155:quantum/quantum.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 156:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 157:quantum/quantum.c ****     if (!disable_action_cache) {
 446               		.loc 1 157 5 is_stmt 1 view .LVU95
 447               		.loc 1 157 8 is_stmt 0 view .LVU96
 448 0016 3091 0000 		lds r19,disable_action_cache
 449 001a 8981      		ldd r24,Y+1
 450 001c 9A81      		ldd r25,Y+2
 451 001e 3111      		cpse r19,__zero_reg__
 452 0020 00C0      		rjmp .L46
 453               	.LBB4:
 158:quantum/quantum.c ****         uint8_t layer;
 454               		.loc 1 158 9 is_stmt 1 view .LVU97
 159:quantum/quantum.c **** 
 160:quantum/quantum.c ****         if (event.pressed && update_layer_cache) {
 455               		.loc 1 160 9 view .LVU98
 456               		.loc 1 160 12 is_stmt 0 view .LVU99
 457 0022 6623      		tst r22
 458 0024 01F0      		breq .L47
 459               		.loc 1 160 27 discriminator 1 view .LVU100
 460 0026 2223      		tst r18
 461 0028 01F0      		breq .L47
 161:quantum/quantum.c ****             layer = layer_switch_get_layer(event.key);
 462               		.loc 1 161 13 is_stmt 1 view .LVU101
 463               		.loc 1 161 21 is_stmt 0 view .LVU102
 464 002a 0E94 0000 		call layer_switch_get_layer
 465               	.LVL37:
 466               		.loc 1 161 21 view .LVU103
 467 002e 182F      		mov r17,r24
 468               	.LVL38:
 162:quantum/quantum.c ****             update_source_layers_cache(event.key, layer);
 469               		.loc 1 162 13 is_stmt 1 view .LVU104
 470 0030 682F      		mov r22,r24
 471 0032 8981      		ldd r24,Y+1
 472 0034 9A81      		ldd r25,Y+2
 473 0036 0E94 0000 		call update_source_layers_cache
 474               	.LVL39:
 475               	.L48:
 163:quantum/quantum.c ****         } else {
 164:quantum/quantum.c ****             layer = read_source_layers_cache(event.key);
 165:quantum/quantum.c ****         }
 166:quantum/quantum.c ****         return keymap_key_to_keycode(layer, event.key);
 476               		.loc 1 166 9 view .LVU105
 477               		.loc 1 166 16 is_stmt 0 view .LVU106
 478 003a 6981      		ldd r22,Y+1
 479 003c 7A81      		ldd r23,Y+2
 480 003e 812F      		mov r24,r17
 481               	.LVL40:
 482               	.L55:
 483               	/* epilogue start */
 484               		.loc 1 166 16 view .LVU107
 485               	.LBE4:
 167:quantum/quantum.c ****     } else
 168:quantum/quantum.c **** #endif
 169:quantum/quantum.c ****         return keymap_key_to_keycode(layer_switch_get_layer(event.key), event.key);
 170:quantum/quantum.c **** }
 486               		.loc 1 170 1 view .LVU108
 487 0040 0F90      		pop __tmp_reg__
 488 0042 0F90      		pop __tmp_reg__
 489 0044 0F90      		pop __tmp_reg__
 490 0046 0F90      		pop __tmp_reg__
 491 0048 0F90      		pop __tmp_reg__
 492 004a DF91      		pop r29
 493 004c CF91      		pop r28
 494 004e 1F91      		pop r17
 169:quantum/quantum.c **** }
 495               		.loc 1 169 16 view .LVU109
 496 0050 0C94 0000 		jmp keymap_key_to_keycode
 497               	.LVL41:
 498               	.L47:
 499               	.LBB5:
 164:quantum/quantum.c ****         }
 500               		.loc 1 164 13 is_stmt 1 view .LVU110
 164:quantum/quantum.c ****         }
 501               		.loc 1 164 21 is_stmt 0 view .LVU111
 502 0054 0E94 0000 		call read_source_layers_cache
 503               	.LVL42:
 164:quantum/quantum.c ****         }
 504               		.loc 1 164 21 view .LVU112
 505 0058 182F      		mov r17,r24
 506               	.LVL43:
 164:quantum/quantum.c ****         }
 507               		.loc 1 164 21 view .LVU113
 508 005a 00C0      		rjmp .L48
 509               	.LVL44:
 510               	.L46:
 164:quantum/quantum.c ****         }
 511               		.loc 1 164 21 view .LVU114
 512               	.LBE5:
 169:quantum/quantum.c **** }
 513               		.loc 1 169 9 is_stmt 1 view .LVU115
 169:quantum/quantum.c **** }
 514               		.loc 1 169 16 is_stmt 0 view .LVU116
 515 005c 0E94 0000 		call layer_switch_get_layer
 516               	.LVL45:
 169:quantum/quantum.c **** }
 517               		.loc 1 169 16 view .LVU117
 518 0060 6981      		ldd r22,Y+1
 519 0062 7A81      		ldd r23,Y+2
 520 0064 00C0      		rjmp .L55
 521               		.cfi_endproc
 522               	.LFE128:
 524               		.section	.text.get_record_keycode,"ax",@progbits
 525               	.global	get_record_keycode
 527               	get_record_keycode:
 528               	.LVL46:
 529               	.LFB127:
 146:quantum/quantum.c **** 
 530               		.loc 1 146 75 is_stmt 1 view -0
 531               		.cfi_startproc
 532               	/* prologue: function */
 533               	/* frame size = 0 */
 534               	/* stack size = 0 */
 535               	.L__stack_usage = 0
 146:quantum/quantum.c **** 
 536               		.loc 1 146 75 is_stmt 0 view .LVU119
 537 0000 FC01      		movw r30,r24
 538 0002 262F      		mov r18,r22
 146:quantum/quantum.c **** 
 539               		.loc 1 146 77 is_stmt 1 view .LVU120
 146:quantum/quantum.c **** 
 540               		.loc 1 146 84 is_stmt 0 view .LVU121
 541 0004 4081      		ld r20,Z
 542 0006 5181      		ldd r21,Z+1
 543 0008 6281      		ldd r22,Z+2
 544               	.LVL47:
 146:quantum/quantum.c **** 
 545               		.loc 1 146 84 view .LVU122
 546 000a 7381      		ldd r23,Z+3
 547 000c 8481      		ldd r24,Z+4
 548               	.LVL48:
 146:quantum/quantum.c **** 
 549               		.loc 1 146 84 view .LVU123
 550 000e 0C94 0000 		jmp get_event_keycode
 551               	.LVL49:
 146:quantum/quantum.c **** 
 552               		.loc 1 146 84 view .LVU124
 553               		.cfi_endproc
 554               	.LFE127:
 556               		.section	.text.post_process_record_quantum,"ax",@progbits
 557               	.global	post_process_record_quantum
 559               	post_process_record_quantum:
 560               	.LVL50:
 561               	.LFB129:
 171:quantum/quantum.c **** 
 172:quantum/quantum.c **** /* Get keycode, and then call keyboard function */
 173:quantum/quantum.c **** void post_process_record_quantum(keyrecord_t *record) {
 562               		.loc 1 173 55 is_stmt 1 view -0
 563               		.cfi_startproc
 564               		.loc 1 173 55 is_stmt 0 view .LVU126
 565 0000 CF93      		push r28
 566               	.LCFI13:
 567               		.cfi_def_cfa_offset 3
 568               		.cfi_offset 28, -2
 569 0002 DF93      		push r29
 570               	.LCFI14:
 571               		.cfi_def_cfa_offset 4
 572               		.cfi_offset 29, -3
 573               	/* prologue: function */
 574               	/* frame size = 0 */
 575               	/* stack size = 2 */
 576               	.L__stack_usage = 2
 577 0004 EC01      		movw r28,r24
 174:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, false);
 578               		.loc 1 174 5 is_stmt 1 view .LVU127
 579               		.loc 1 174 24 is_stmt 0 view .LVU128
 580 0006 60E0      		ldi r22,0
 581 0008 0E94 0000 		call get_record_keycode
 582               	.LVL51:
 175:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 583               		.loc 1 175 5 is_stmt 1 view .LVU129
 584 000c BE01      		movw r22,r28
 585               	/* epilogue start */
 176:quantum/quantum.c **** }
 586               		.loc 1 176 1 is_stmt 0 view .LVU130
 587 000e DF91      		pop r29
 588 0010 CF91      		pop r28
 589               	.LVL52:
 175:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 590               		.loc 1 175 5 view .LVU131
 591 0012 0C94 0000 		jmp post_process_record_kb
 592               	.LVL53:
 175:quantum/quantum.c ****     post_process_record_kb(keycode, record);
 593               		.loc 1 175 5 view .LVU132
 594               		.cfi_endproc
 595               	.LFE129:
 597               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 598               	.global	set_single_persistent_default_layer
 600               	set_single_persistent_default_layer:
 601               	.LVL54:
 602               	.LFB131:
 177:quantum/quantum.c **** 
 178:quantum/quantum.c **** /* Core keycode function, hands off handling to other functions,
 179:quantum/quantum.c ****     then processes internal quantum keycodes, and then processes
 180:quantum/quantum.c ****     ACTIONs.                                                      */
 181:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 182:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 183:quantum/quantum.c **** 
 184:quantum/quantum.c ****     // This is how you use actions here
 185:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 186:quantum/quantum.c ****     //   action_t action;
 187:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 188:quantum/quantum.c ****     //   process_action(record, action);
 189:quantum/quantum.c ****     //   return false;
 190:quantum/quantum.c ****     // }
 191:quantum/quantum.c **** 
 192:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 193:quantum/quantum.c ****     if (velocikey_enabled() && record->event.pressed) {
 194:quantum/quantum.c ****         velocikey_accelerate();
 195:quantum/quantum.c ****     }
 196:quantum/quantum.c **** #endif
 197:quantum/quantum.c **** 
 198:quantum/quantum.c **** #ifdef WPM_ENABLE
 199:quantum/quantum.c ****     if (record->event.pressed) {
 200:quantum/quantum.c ****         update_wpm(keycode);
 201:quantum/quantum.c ****     }
 202:quantum/quantum.c **** #endif
 203:quantum/quantum.c **** 
 204:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 205:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 206:quantum/quantum.c **** #endif
 207:quantum/quantum.c **** 
 208:quantum/quantum.c ****     if (!(
 209:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 210:quantum/quantum.c ****             // Must run first to be able to mask key_up events.
 211:quantum/quantum.c ****             process_key_lock(&keycode, record) &&
 212:quantum/quantum.c **** #endif
 213:quantum/quantum.c **** #if defined(DYNAMIC_MACRO_ENABLE) && !defined(DYNAMIC_MACRO_USER_CALL)
 214:quantum/quantum.c ****             // Must run asap to ensure all keypresses are recorded.
 215:quantum/quantum.c ****             process_dynamic_macro(keycode, record) &&
 216:quantum/quantum.c **** #endif
 217:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 218:quantum/quantum.c ****             process_clicky(keycode, record) &&
 219:quantum/quantum.c **** #endif  // AUDIO_CLICKY
 220:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 221:quantum/quantum.c ****             process_haptic(keycode, record) &&
 222:quantum/quantum.c **** #endif  // HAPTIC_ENABLE
 223:quantum/quantum.c **** #if defined(VIA_ENABLE)
 224:quantum/quantum.c ****             process_record_via(keycode, record) &&
 225:quantum/quantum.c **** #endif
 226:quantum/quantum.c ****             process_record_kb(keycode, record) &&
 227:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 228:quantum/quantum.c ****             process_sequencer(keycode, record) &&
 229:quantum/quantum.c **** #endif
 230:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 231:quantum/quantum.c ****             process_midi(keycode, record) &&
 232:quantum/quantum.c **** #endif
 233:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 234:quantum/quantum.c ****             process_audio(keycode, record) &&
 235:quantum/quantum.c **** #endif
 236:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
 237:quantum/quantum.c ****             process_backlight(keycode, record) &&
 238:quantum/quantum.c **** #endif
 239:quantum/quantum.c **** #ifdef STENO_ENABLE
 240:quantum/quantum.c ****             process_steno(keycode, record) &&
 241:quantum/quantum.c **** #endif
 242:quantum/quantum.c **** #if (defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSIC_M
 243:quantum/quantum.c ****             process_music(keycode, record) &&
 244:quantum/quantum.c **** #endif
 245:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 246:quantum/quantum.c ****             process_tap_dance(keycode, record) &&
 247:quantum/quantum.c **** #endif
 248:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 249:quantum/quantum.c ****             process_unicode_common(keycode, record) &&
 250:quantum/quantum.c **** #endif
 251:quantum/quantum.c **** #ifdef LEADER_ENABLE
 252:quantum/quantum.c ****             process_leader(keycode, record) &&
 253:quantum/quantum.c **** #endif
 254:quantum/quantum.c **** #ifdef COMBO_ENABLE
 255:quantum/quantum.c ****             process_combo(keycode, record) &&
 256:quantum/quantum.c **** #endif
 257:quantum/quantum.c **** #ifdef PRINTING_ENABLE
 258:quantum/quantum.c ****             process_printer(keycode, record) &&
 259:quantum/quantum.c **** #endif
 260:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 261:quantum/quantum.c ****             process_auto_shift(keycode, record) &&
 262:quantum/quantum.c **** #endif
 263:quantum/quantum.c **** #ifdef TERMINAL_ENABLE
 264:quantum/quantum.c ****             process_terminal(keycode, record) &&
 265:quantum/quantum.c **** #endif
 266:quantum/quantum.c **** #ifdef SPACE_CADET_ENABLE
 267:quantum/quantum.c ****             process_space_cadet(keycode, record) &&
 268:quantum/quantum.c **** #endif
 269:quantum/quantum.c **** #ifdef MAGIC_KEYCODE_ENABLE
 270:quantum/quantum.c ****             process_magic(keycode, record) &&
 271:quantum/quantum.c **** #endif
 272:quantum/quantum.c **** #ifdef GRAVE_ESC_ENABLE
 273:quantum/quantum.c ****             process_grave_esc(keycode, record) &&
 274:quantum/quantum.c **** #endif
 275:quantum/quantum.c **** #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 276:quantum/quantum.c ****             process_rgb(keycode, record) &&
 277:quantum/quantum.c **** #endif
 278:quantum/quantum.c **** #ifdef JOYSTICK_ENABLE
 279:quantum/quantum.c ****             process_joystick(keycode, record) &&
 280:quantum/quantum.c **** #endif
 281:quantum/quantum.c ****             true)) {
 282:quantum/quantum.c ****         return false;
 283:quantum/quantum.c ****     }
 284:quantum/quantum.c **** 
 285:quantum/quantum.c ****     if (record->event.pressed) {
 286:quantum/quantum.c ****         switch (keycode) {
 287:quantum/quantum.c **** #ifndef NO_RESET
 288:quantum/quantum.c ****             case RESET:
 289:quantum/quantum.c ****                 reset_keyboard();
 290:quantum/quantum.c ****                 return false;
 291:quantum/quantum.c **** #endif
 292:quantum/quantum.c **** #ifndef NO_DEBUG
 293:quantum/quantum.c ****             case DEBUG:
 294:quantum/quantum.c ****                 debug_enable ^= 1;
 295:quantum/quantum.c ****                 if (debug_enable) {
 296:quantum/quantum.c ****                     print("DEBUG: enabled.\n");
 297:quantum/quantum.c ****                 } else {
 298:quantum/quantum.c ****                     print("DEBUG: disabled.\n");
 299:quantum/quantum.c ****                 }
 300:quantum/quantum.c **** #endif
 301:quantum/quantum.c ****                 return false;
 302:quantum/quantum.c ****             case EEPROM_RESET:
 303:quantum/quantum.c ****                 eeconfig_init();
 304:quantum/quantum.c ****                 return false;
 305:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 306:quantum/quantum.c ****             case VLK_TOG:
 307:quantum/quantum.c ****                 velocikey_toggle();
 308:quantum/quantum.c ****                 return false;
 309:quantum/quantum.c **** #endif
 310:quantum/quantum.c **** #ifdef BLUETOOTH_ENABLE
 311:quantum/quantum.c ****             case OUT_AUTO:
 312:quantum/quantum.c ****                 set_output(OUTPUT_AUTO);
 313:quantum/quantum.c ****                 return false;
 314:quantum/quantum.c ****             case OUT_USB:
 315:quantum/quantum.c ****                 set_output(OUTPUT_USB);
 316:quantum/quantum.c ****                 return false;
 317:quantum/quantum.c ****             case OUT_BT:
 318:quantum/quantum.c ****                 set_output(OUTPUT_BLUETOOTH);
 319:quantum/quantum.c ****                 return false;
 320:quantum/quantum.c **** #endif
 321:quantum/quantum.c ****         }
 322:quantum/quantum.c ****     }
 323:quantum/quantum.c **** 
 324:quantum/quantum.c ****     return process_action_kb(record);
 325:quantum/quantum.c **** }
 326:quantum/quantum.c **** 
 327:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 603               		.loc 1 327 65 is_stmt 1 view -0
 604               		.cfi_startproc
 605               		.loc 1 327 65 is_stmt 0 view .LVU134
 606 0000 CF93      		push r28
 607               	.LCFI15:
 608               		.cfi_def_cfa_offset 3
 609               		.cfi_offset 28, -2
 610 0002 DF93      		push r29
 611               	.LCFI16:
 612               		.cfi_def_cfa_offset 4
 613               		.cfi_offset 29, -3
 614               	/* prologue: function */
 615               	/* frame size = 0 */
 616               	/* stack size = 2 */
 617               	.L__stack_usage = 2
 328:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 329:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 330:quantum/quantum.c **** #endif
 331:quantum/quantum.c ****     eeconfig_update_default_layer(1U << default_layer);
 618               		.loc 1 331 5 is_stmt 1 view .LVU135
 619               		.loc 1 331 38 is_stmt 0 view .LVU136
 620 0004 C1E0      		ldi r28,lo8(1)
 621 0006 D0E0      		ldi r29,0
 622 0008 00C0      		rjmp 2f
 623               		1:
 624 000a CC0F      		lsl r28
 625 000c DD1F      		rol r29
 626               		2:
 627 000e 8A95      		dec r24
 628 0010 02F4      		brpl 1b
 629               		.loc 1 331 5 view .LVU137
 630 0012 8C2F      		mov r24,r28
 631               	.LVL55:
 632               		.loc 1 331 5 view .LVU138
 633 0014 0E94 0000 		call eeconfig_update_default_layer
 634               	.LVL56:
 332:quantum/quantum.c ****     default_layer_set(1U << default_layer);
 635               		.loc 1 332 5 is_stmt 1 view .LVU139
 636 0018 BE01      		movw r22,r28
 637 001a 90E0      		ldi r25,0
 638 001c 80E0      		ldi r24,0
 639               	/* epilogue start */
 333:quantum/quantum.c **** }
 640               		.loc 1 333 1 is_stmt 0 view .LVU140
 641 001e DF91      		pop r29
 642 0020 CF91      		pop r28
 332:quantum/quantum.c ****     default_layer_set(1U << default_layer);
 643               		.loc 1 332 5 view .LVU141
 644 0022 0C94 0000 		jmp default_layer_set
 645               	.LVL57:
 646               		.cfi_endproc
 647               	.LFE131:
 649               		.section	.text.update_tri_layer_state,"ax",@progbits
 650               	.global	update_tri_layer_state
 652               	update_tri_layer_state:
 653               	.LVL58:
 654               	.LFB132:
 334:quantum/quantum.c **** 
 335:quantum/quantum.c **** layer_state_t update_tri_layer_state(layer_state_t state, uint8_t layer1, uint8_t layer2, uint8_t l
 655               		.loc 1 335 107 is_stmt 1 view -0
 656               		.cfi_startproc
 657               		.loc 1 335 107 is_stmt 0 view .LVU143
 658 0000 8F92      		push r8
 659               	.LCFI17:
 660               		.cfi_def_cfa_offset 3
 661               		.cfi_offset 8, -2
 662 0002 9F92      		push r9
 663               	.LCFI18:
 664               		.cfi_def_cfa_offset 4
 665               		.cfi_offset 9, -3
 666 0004 AF92      		push r10
 667               	.LCFI19:
 668               		.cfi_def_cfa_offset 5
 669               		.cfi_offset 10, -4
 670 0006 BF92      		push r11
 671               	.LCFI20:
 672               		.cfi_def_cfa_offset 6
 673               		.cfi_offset 11, -5
 674 0008 CF92      		push r12
 675               	.LCFI21:
 676               		.cfi_def_cfa_offset 7
 677               		.cfi_offset 12, -6
 678 000a DF92      		push r13
 679               	.LCFI22:
 680               		.cfi_def_cfa_offset 8
 681               		.cfi_offset 13, -7
 682 000c EF92      		push r14
 683               	.LCFI23:
 684               		.cfi_def_cfa_offset 9
 685               		.cfi_offset 14, -8
 686 000e FF92      		push r15
 687               	.LCFI24:
 688               		.cfi_def_cfa_offset 10
 689               		.cfi_offset 15, -9
 690 0010 0F93      		push r16
 691               	.LCFI25:
 692               		.cfi_def_cfa_offset 11
 693               		.cfi_offset 16, -10
 694 0012 1F93      		push r17
 695               	.LCFI26:
 696               		.cfi_def_cfa_offset 12
 697               		.cfi_offset 17, -11
 698               	/* prologue: function */
 699               	/* frame size = 0 */
 700               	/* stack size = 10 */
 701               	.L__stack_usage = 10
 702 0014 6B01      		movw r12,r22
 703 0016 7C01      		movw r14,r24
 336:quantum/quantum.c ****     layer_state_t mask12 = (1UL << layer1) | (1UL << layer2);
 704               		.loc 1 336 5 is_stmt 1 view .LVU144
 705               		.loc 1 336 33 is_stmt 0 view .LVU145
 706 0018 81E0      		ldi r24,lo8(1)
 707 001a 90E0      		ldi r25,0
 708 001c A0E0      		ldi r26,0
 709 001e B0E0      		ldi r27,0
 710 0020 4C01      		movw r8,r24
 711 0022 5D01      		movw r10,r26
 712 0024 00C0      		rjmp 2f
 713               		1:
 714 0026 880C      		lsl r8
 715 0028 991C      		rol r9
 716 002a AA1C      		rol r10
 717 002c BB1C      		rol r11
 718               		2:
 719 002e 4A95      		dec r20
 720 0030 02F4      		brpl 1b
 721 0032 B501      		movw r22,r10
 722               	.LVL59:
 723               		.loc 1 336 33 view .LVU146
 724 0034 A401      		movw r20,r8
 725               	.LVL60:
 726               		.loc 1 336 51 view .LVU147
 727 0036 4C01      		movw r8,r24
 728 0038 5D01      		movw r10,r26
 729 003a 00C0      		rjmp 2f
 730               		1:
 731 003c 880C      		lsl r8
 732 003e 991C      		rol r9
 733 0040 AA1C      		rol r10
 734 0042 BB1C      		rol r11
 735               		2:
 736 0044 2A95      		dec r18
 737 0046 02F4      		brpl 1b
 738               		.loc 1 336 19 view .LVU148
 739 0048 4829      		or r20,r8
 740 004a 5929      		or r21,r9
 741 004c 6A29      		or r22,r10
 742 004e 7B29      		or r23,r11
 743               	.LVL61:
 337:quantum/quantum.c ****     layer_state_t mask3  = 1UL << layer3;
 744               		.loc 1 337 5 is_stmt 1 view .LVU149
 745               		.loc 1 337 19 is_stmt 0 view .LVU150
 746 0050 00C0      		rjmp 2f
 747               		1:
 748 0052 880F      		lsl r24
 749 0054 991F      		rol r25
 750 0056 AA1F      		rol r26
 751 0058 BB1F      		rol r27
 752               		2:
 753 005a 0A95      		dec r16
 754 005c 02F4      		brpl 1b
 755               	.LVL62:
 338:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 756               		.loc 1 338 5 is_stmt 1 view .LVU151
 757               		.loc 1 338 19 is_stmt 0 view .LVU152
 758 005e 8A01      		movw r16,r20
 759               	.LVL63:
 760               		.loc 1 338 19 view .LVU153
 761 0060 9B01      		movw r18,r22
 762               	.LVL64:
 763               		.loc 1 338 19 view .LVU154
 764 0062 0C21      		and r16,r12
 765 0064 1D21      		and r17,r13
 766 0066 2E21      		and r18,r14
 767 0068 3F21      		and r19,r15
 768               		.loc 1 338 57 view .LVU155
 769 006a 0417      		cp r16,r20
 770 006c 1507      		cpc r17,r21
 771 006e 2607      		cpc r18,r22
 772 0070 3707      		cpc r19,r23
 773 0072 01F4      		brne .L60
 774               		.loc 1 338 57 discriminator 1 view .LVU156
 775 0074 8C29      		or r24,r12
 776               	.LVL65:
 777               		.loc 1 338 57 discriminator 1 view .LVU157
 778 0076 9D29      		or r25,r13
 779 0078 AE29      		or r26,r14
 780 007a BF29      		or r27,r15
 781               	.L59:
 339:quantum/quantum.c **** }
 782               		.loc 1 339 1 view .LVU158
 783 007c BC01      		movw r22,r24
 784 007e CD01      		movw r24,r26
 785               	/* epilogue start */
 786 0080 1F91      		pop r17
 787               	.LVL66:
 788               		.loc 1 339 1 view .LVU159
 789 0082 0F91      		pop r16
 790               	.LVL67:
 791               		.loc 1 339 1 view .LVU160
 792 0084 FF90      		pop r15
 793 0086 EF90      		pop r14
 794 0088 DF90      		pop r13
 795 008a CF90      		pop r12
 796 008c BF90      		pop r11
 797 008e AF90      		pop r10
 798 0090 9F90      		pop r9
 799 0092 8F90      		pop r8
 800               	.LVL68:
 801               		.loc 1 339 1 view .LVU161
 802 0094 0895      		ret
 803               	.LVL69:
 804               	.L60:
 338:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 805               		.loc 1 338 68 discriminator 2 view .LVU162
 806 0096 8095      		com r24
 807 0098 9095      		com r25
 808 009a A095      		com r26
 809 009c B095      		com r27
 810               	.LVL70:
 338:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 811               		.loc 1 338 57 discriminator 2 view .LVU163
 812 009e 8C21      		and r24,r12
 813               	.LVL71:
 338:quantum/quantum.c ****     return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 814               		.loc 1 338 57 discriminator 2 view .LVU164
 815 00a0 9D21      		and r25,r13
 816 00a2 AE21      		and r26,r14
 817 00a4 BF21      		and r27,r15
 818 00a6 00C0      		rjmp .L59
 819               		.cfi_endproc
 820               	.LFE132:
 822               		.section	.text.update_tri_layer,"ax",@progbits
 823               	.global	update_tri_layer
 825               	update_tri_layer:
 826               	.LVL72:
 827               	.LFB133:
 340:quantum/quantum.c **** 
 341:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) { layer_state_set(update_tri_
 828               		.loc 1 341 71 is_stmt 1 view -0
 829               		.cfi_startproc
 830               		.loc 1 341 71 is_stmt 0 view .LVU166
 831 0000 0F93      		push r16
 832               	.LCFI27:
 833               		.cfi_def_cfa_offset 3
 834               		.cfi_offset 16, -2
 835               	/* prologue: function */
 836               	/* frame size = 0 */
 837               	/* stack size = 1 */
 838               	.L__stack_usage = 1
 839 0002 382F      		mov r19,r24
 840 0004 262F      		mov r18,r22
 841               		.loc 1 341 73 is_stmt 1 view .LVU167
 842 0006 6091 0000 		lds r22,layer_state
 843 000a 7091 0000 		lds r23,layer_state+1
 844 000e 8091 0000 		lds r24,layer_state+2
 845 0012 9091 0000 		lds r25,layer_state+3
 846               	.LVL73:
 847               		.loc 1 341 73 is_stmt 0 view .LVU168
 848 0016 042F      		mov r16,r20
 849 0018 432F      		mov r20,r19
 850               	.LVL74:
 851               		.loc 1 341 73 view .LVU169
 852 001a 0E94 0000 		call update_tri_layer_state
 853               	.LVL75:
 854               	/* epilogue start */
 855               		.loc 1 341 1 view .LVU170
 856 001e 0F91      		pop r16
 857               	.LVL76:
 858               		.loc 1 341 73 view .LVU171
 859 0020 0C94 0000 		jmp layer_state_set
 860               	.LVL77:
 861               		.cfi_endproc
 862               	.LFE133:
 864               		.section	.text.matrix_init_quantum,"ax",@progbits
 865               	.global	matrix_init_quantum
 867               	matrix_init_quantum:
 868               	.LFB134:
 342:quantum/quantum.c **** 
 343:quantum/quantum.c **** void matrix_init_quantum() {
 869               		.loc 1 343 28 is_stmt 1 view -0
 870               		.cfi_startproc
 871               	/* prologue: function */
 872               	/* frame size = 0 */
 873               	/* stack size = 0 */
 874               	.L__stack_usage = 0
 344:quantum/quantum.c **** #ifdef BOOTMAGIC_LITE
 345:quantum/quantum.c ****     bootmagic_lite();
 346:quantum/quantum.c **** #endif
 347:quantum/quantum.c ****     if (!eeconfig_is_enabled()) {
 875               		.loc 1 347 5 view .LVU173
 876               		.loc 1 347 10 is_stmt 0 view .LVU174
 877 0000 0E94 0000 		call eeconfig_is_enabled
 878               	.LVL78:
 879               		.loc 1 347 8 view .LVU175
 880 0004 8111      		cpse r24,__zero_reg__
 881 0006 00C0      		rjmp .L64
 348:quantum/quantum.c ****         eeconfig_init();
 882               		.loc 1 348 9 is_stmt 1 view .LVU176
 883 0008 0E94 0000 		call eeconfig_init
 884               	.LVL79:
 885               	.L64:
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c **** #if defined(LED_NUM_LOCK_PIN) || defined(LED_CAPS_LOCK_PIN) || defined(LED_SCROLL_LOCK_PIN) || defi
 351:quantum/quantum.c ****     // TODO: remove calls to led_init_ports from keyboards and remove ifdef
 352:quantum/quantum.c ****     led_init_ports();
 886               		.loc 1 352 5 view .LVU177
 887 000c 0E94 0000 		call led_init_ports
 888               	.LVL80:
 353:quantum/quantum.c **** #endif
 354:quantum/quantum.c **** #ifdef BACKLIGHT_ENABLE
 355:quantum/quantum.c **** #    ifdef LED_MATRIX_ENABLE
 356:quantum/quantum.c ****     led_matrix_init();
 357:quantum/quantum.c **** #    else
 358:quantum/quantum.c ****     backlight_init_ports();
 889               		.loc 1 358 5 view .LVU178
 890 0010 0E94 0000 		call backlight_init_ports
 891               	.LVL81:
 359:quantum/quantum.c **** #    endif
 360:quantum/quantum.c **** #endif
 361:quantum/quantum.c **** #ifdef AUDIO_ENABLE
 362:quantum/quantum.c ****     audio_init();
 363:quantum/quantum.c **** #endif
 364:quantum/quantum.c **** #ifdef RGB_MATRIX_ENABLE
 365:quantum/quantum.c ****     rgb_matrix_init();
 366:quantum/quantum.c **** #endif
 367:quantum/quantum.c **** #if defined(UNICODE_ENABLE) || defined(UNICODEMAP_ENABLE) || defined(UCIS_ENABLE)
 368:quantum/quantum.c ****     unicode_input_mode_init();
 892               		.loc 1 368 5 view .LVU179
 893 0014 0E94 0000 		call unicode_input_mode_init
 894               	.LVL82:
 369:quantum/quantum.c **** #endif
 370:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 371:quantum/quantum.c ****     haptic_init();
 372:quantum/quantum.c **** #endif
 373:quantum/quantum.c **** #if defined(BLUETOOTH_ENABLE) && defined(OUTPUT_AUTO_ENABLE)
 374:quantum/quantum.c ****     set_output(OUTPUT_AUTO);
 375:quantum/quantum.c **** #endif
 376:quantum/quantum.c **** 
 377:quantum/quantum.c ****     matrix_init_kb();
 895               		.loc 1 377 5 view .LVU180
 896 0018 0C94 0000 		jmp matrix_init_kb
 897               	.LVL83:
 898               		.cfi_endproc
 899               	.LFE134:
 901               		.section	.text.matrix_scan_quantum,"ax",@progbits
 902               	.global	matrix_scan_quantum
 904               	matrix_scan_quantum:
 905               	.LFB135:
 378:quantum/quantum.c **** }
 379:quantum/quantum.c **** 
 380:quantum/quantum.c **** void matrix_scan_quantum() {
 906               		.loc 1 380 28 view -0
 907               		.cfi_startproc
 908               	/* prologue: function */
 909               	/* frame size = 0 */
 910               	/* stack size = 0 */
 911               	.L__stack_usage = 0
 381:quantum/quantum.c **** #if defined(AUDIO_ENABLE)
 382:quantum/quantum.c ****     // There are some tasks that need to be run a little bit
 383:quantum/quantum.c ****     // after keyboard startup, or else they will not work correctly
 384:quantum/quantum.c ****     // because of interaction with the USB device state, which
 385:quantum/quantum.c ****     // may still be in flux...
 386:quantum/quantum.c ****     //
 387:quantum/quantum.c ****     // At the moment the only feature that needs this is the
 388:quantum/quantum.c ****     // startup song.
 389:quantum/quantum.c ****     static bool     delayed_tasks_run  = false;
 390:quantum/quantum.c ****     static uint16_t delayed_task_timer = 0;
 391:quantum/quantum.c ****     if (!delayed_tasks_run) {
 392:quantum/quantum.c ****         if (!delayed_task_timer) {
 393:quantum/quantum.c ****             delayed_task_timer = timer_read();
 394:quantum/quantum.c ****         } else if (timer_elapsed(delayed_task_timer) > 300) {
 395:quantum/quantum.c ****             audio_startup();
 396:quantum/quantum.c ****             delayed_tasks_run = true;
 397:quantum/quantum.c ****         }
 398:quantum/quantum.c ****     }
 399:quantum/quantum.c **** #endif
 400:quantum/quantum.c **** 
 401:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 402:quantum/quantum.c ****     matrix_scan_music();
 403:quantum/quantum.c **** #endif
 404:quantum/quantum.c **** 
 405:quantum/quantum.c **** #ifdef SEQUENCER_ENABLE
 406:quantum/quantum.c ****     matrix_scan_sequencer();
 407:quantum/quantum.c **** #endif
 408:quantum/quantum.c **** 
 409:quantum/quantum.c **** #ifdef TAP_DANCE_ENABLE
 410:quantum/quantum.c ****     matrix_scan_tap_dance();
 411:quantum/quantum.c **** #endif
 412:quantum/quantum.c **** 
 413:quantum/quantum.c **** #ifdef COMBO_ENABLE
 414:quantum/quantum.c ****     matrix_scan_combo();
 415:quantum/quantum.c **** #endif
 416:quantum/quantum.c **** 
 417:quantum/quantum.c **** #ifdef LED_MATRIX_ENABLE
 418:quantum/quantum.c ****     led_matrix_task();
 419:quantum/quantum.c **** #endif
 420:quantum/quantum.c **** 
 421:quantum/quantum.c **** #ifdef WPM_ENABLE
 422:quantum/quantum.c ****     decay_wpm();
 423:quantum/quantum.c **** #endif
 424:quantum/quantum.c **** 
 425:quantum/quantum.c **** #ifdef HAPTIC_ENABLE
 426:quantum/quantum.c ****     haptic_task();
 427:quantum/quantum.c **** #endif
 428:quantum/quantum.c **** 
 429:quantum/quantum.c **** #ifdef DIP_SWITCH_ENABLE
 430:quantum/quantum.c ****     dip_switch_read(false);
 431:quantum/quantum.c **** #endif
 432:quantum/quantum.c **** 
 433:quantum/quantum.c **** #ifdef AUTO_SHIFT_ENABLE
 434:quantum/quantum.c ****     autoshift_matrix_scan();
 435:quantum/quantum.c **** #endif
 436:quantum/quantum.c **** 
 437:quantum/quantum.c ****     matrix_scan_kb();
 912               		.loc 1 437 5 view .LVU182
 913 0000 0C94 0000 		jmp matrix_scan_kb
 914               	.LVL84:
 915               		.cfi_endproc
 916               	.LFE135:
 918               		.section	.text.api_send_unicode,"ax",@progbits
 919               	.global	api_send_unicode
 921               	api_send_unicode:
 922               	.LVL85:
 923               	.LFB136:
 438:quantum/quantum.c **** }
 439:quantum/quantum.c **** 
 440:quantum/quantum.c **** #ifdef HD44780_ENABLED
 441:quantum/quantum.c **** #    include "hd44780.h"
 442:quantum/quantum.c **** #endif
 443:quantum/quantum.c **** 
 444:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 924               		.loc 1 444 41 view -0
 925               		.cfi_startproc
 926               	/* prologue: function */
 927               	/* frame size = 0 */
 928               	/* stack size = 0 */
 929               	.L__stack_usage = 0
 445:quantum/quantum.c **** #ifdef API_ENABLE
 446:quantum/quantum.c ****     uint8_t chunk[4];
 447:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
 448:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
 449:quantum/quantum.c **** #endif
 450:quantum/quantum.c **** }
 930               		.loc 1 450 1 view .LVU184
 931               	/* epilogue start */
 932 0000 0895      		ret
 933               		.cfi_endproc
 934               	.LFE136:
 936               		.section	.text.startup_user,"ax",@progbits
 937               		.weak	startup_user
 939               	startup_user:
 940               	.LFB137:
 451:quantum/quantum.c **** 
 452:quantum/quantum.c **** //------------------------------------------------------------------------------
 453:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
 454:quantum/quantum.c **** // different events such as startup and bootloader jump
 455:quantum/quantum.c **** 
 456:quantum/quantum.c **** __attribute__((weak)) void startup_user() {}
 941               		.loc 1 456 43 view -0
 942               		.cfi_startproc
 943               	/* prologue: function */
 944               	/* frame size = 0 */
 945               	/* stack size = 0 */
 946               	.L__stack_usage = 0
 947               		.loc 1 456 44 view .LVU186
 948               	/* epilogue start */
 949               		.loc 1 456 1 is_stmt 0 view .LVU187
 950 0000 0895      		ret
 951               		.cfi_endproc
 952               	.LFE137:
 954               		.section	.text.shutdown_user,"ax",@progbits
 955               		.weak	shutdown_user
 957               	shutdown_user:
 958               	.LFB140:
 959               		.cfi_startproc
 960               	/* prologue: function */
 961               	/* frame size = 0 */
 962               	/* stack size = 0 */
 963               	.L__stack_usage = 0
 964               	/* epilogue start */
 965 0000 0895      		ret
 966               		.cfi_endproc
 967               	.LFE140:
 969               		.section	.text.reset_keyboard,"ax",@progbits
 970               	.global	reset_keyboard
 972               	reset_keyboard:
 973               	.LFB126:
 121:quantum/quantum.c ****     clear_keyboard();
 974               		.loc 1 121 27 is_stmt 1 view -0
 975               		.cfi_startproc
 976               	/* prologue: function */
 977               	/* frame size = 0 */
 978               	/* stack size = 0 */
 979               	.L__stack_usage = 0
 122:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 980               		.loc 1 122 5 view .LVU189
 981 0000 0E94 0000 		call clear_keyboard
 982               	.LVL86:
 136:quantum/quantum.c ****     wait_ms(250);
 983               		.loc 1 136 5 view .LVU190
 984 0004 0E94 0000 		call shutdown_user
 985               	.LVL87:
 137:quantum/quantum.c **** #endif
 986               		.loc 1 137 5 view .LVU191
 987               	.LBB6:
 988               	.LBI6:
 989               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** _delay_ms(double __ms)
 990               		.loc 2 166 1 view .LVU192
 991               	.LBB7:
 167:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	double __tmp ;
 992               		.loc 2 168 2 view .LVU193
 169:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 993               		.loc 2 172 2 view .LVU194
 173:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 994               		.loc 2 173 2 view .LVU195
 174:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 995               		.loc 2 174 2 view .LVU196
 175:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 996               		.loc 2 184 3 view .LVU197
 185:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 997               		.loc 2 187 2 view .LVU198
 998 0008 2FEF      		ldi r18,lo8(799999)
 999 000a 84E3      		ldi r24,hi8(799999)
 1000 000c 9CE0      		ldi r25,hlo8(799999)
 1001 000e 2150      	1:	subi r18,1
 1002 0010 8040      		sbci r24,0
 1003 0012 9040      		sbci r25,0
 1004 0014 01F4      		brne 1b
 1005 0016 00C0      		rjmp .
 1006 0018 0000      		nop
 1007               	.LVL88:
 1008               		.loc 2 187 2 is_stmt 0 view .LVU199
 1009               	.LBE7:
 1010               	.LBE6:
 142:quantum/quantum.c **** }
 1011               		.loc 1 142 5 is_stmt 1 view .LVU200
 1012 001a 0C94 0000 		jmp bootloader_jump
 1013               	.LVL89:
 1014               		.cfi_endproc
 1015               	.LFE126:
 1017               		.section	.text.process_record_quantum,"ax",@progbits
 1018               	.global	process_record_quantum
 1020               	process_record_quantum:
 1021               	.LVL90:
 1022               	.LFB130:
 181:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 1023               		.loc 1 181 50 view -0
 1024               		.cfi_startproc
 181:quantum/quantum.c ****     uint16_t keycode = get_record_keycode(record, true);
 1025               		.loc 1 181 50 is_stmt 0 view .LVU202
 1026 0000 0F93      		push r16
 1027               	.LCFI28:
 1028               		.cfi_def_cfa_offset 3
 1029               		.cfi_offset 16, -2
 1030 0002 1F93      		push r17
 1031               	.LCFI29:
 1032               		.cfi_def_cfa_offset 4
 1033               		.cfi_offset 17, -3
 1034 0004 CF93      		push r28
 1035               	.LCFI30:
 1036               		.cfi_def_cfa_offset 5
 1037               		.cfi_offset 28, -4
 1038 0006 DF93      		push r29
 1039               	.LCFI31:
 1040               		.cfi_def_cfa_offset 6
 1041               		.cfi_offset 29, -5
 1042               	/* prologue: function */
 1043               	/* frame size = 0 */
 1044               	/* stack size = 4 */
 1045               	.L__stack_usage = 4
 1046 0008 EC01      		movw r28,r24
 182:quantum/quantum.c **** 
 1047               		.loc 1 182 5 is_stmt 1 view .LVU203
 182:quantum/quantum.c **** 
 1048               		.loc 1 182 24 is_stmt 0 view .LVU204
 1049 000a 61E0      		ldi r22,lo8(1)
 1050 000c 0E94 0000 		call get_record_keycode
 1051               	.LVL91:
 182:quantum/quantum.c **** 
 1052               		.loc 1 182 24 view .LVU205
 1053 0010 8C01      		movw r16,r24
 1054               	.LVL92:
 208:quantum/quantum.c **** #if defined(KEY_LOCK_ENABLE)
 1055               		.loc 1 208 5 is_stmt 1 view .LVU206
 226:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 1056               		.loc 1 226 13 is_stmt 0 view .LVU207
 1057 0012 BE01      		movw r22,r28
 1058 0014 0E94 0000 		call process_record_kb
 1059               	.LVL93:
 273:quantum/quantum.c **** #endif
 1060               		.loc 1 273 48 view .LVU208
 1061 0018 8823      		tst r24
 1062 001a 01F0      		breq .L70
 237:quantum/quantum.c **** #endif
 1063               		.loc 1 237 13 view .LVU209
 1064 001c BE01      		movw r22,r28
 1065 001e C801      		movw r24,r16
 1066 0020 0E94 0000 		call process_backlight
 1067               	.LVL94:
 226:quantum/quantum.c **** #if defined(SEQUENCER_ENABLE)
 1068               		.loc 1 226 48 view .LVU210
 1069 0024 8823      		tst r24
 1070 0026 01F0      		breq .L70
 249:quantum/quantum.c **** #endif
 1071               		.loc 1 249 13 view .LVU211
 1072 0028 BE01      		movw r22,r28
 1073 002a C801      		movw r24,r16
 1074 002c 0E94 0000 		call process_unicode_common
 1075               	.LVL95:
 237:quantum/quantum.c **** #endif
 1076               		.loc 1 237 48 view .LVU212
 1077 0030 8823      		tst r24
 1078 0032 01F0      		breq .L70
 267:quantum/quantum.c **** #endif
 1079               		.loc 1 267 13 view .LVU213
 1080 0034 BE01      		movw r22,r28
 1081 0036 C801      		movw r24,r16
 1082 0038 0E94 0000 		call process_space_cadet
 1083               	.LVL96:
 249:quantum/quantum.c **** #endif
 1084               		.loc 1 249 53 view .LVU214
 1085 003c 8823      		tst r24
 1086 003e 01F0      		breq .L70
 270:quantum/quantum.c **** #endif
 1087               		.loc 1 270 13 view .LVU215
 1088 0040 BE01      		movw r22,r28
 1089 0042 C801      		movw r24,r16
 1090 0044 0E94 0000 		call process_magic
 1091               	.LVL97:
 267:quantum/quantum.c **** #endif
 1092               		.loc 1 267 50 view .LVU216
 1093 0048 8823      		tst r24
 1094 004a 01F0      		breq .L70
 273:quantum/quantum.c **** #endif
 1095               		.loc 1 273 13 view .LVU217
 1096 004c BE01      		movw r22,r28
 1097 004e C801      		movw r24,r16
 1098 0050 0E94 0000 		call process_grave_esc
 1099               	.LVL98:
 270:quantum/quantum.c **** #endif
 1100               		.loc 1 270 44 view .LVU218
 1101 0054 8823      		tst r24
 1102 0056 01F0      		breq .L70
 276:quantum/quantum.c **** #endif
 1103               		.loc 1 276 13 discriminator 2 view .LVU219
 1104 0058 BE01      		movw r22,r28
 1105 005a C801      		movw r24,r16
 1106 005c 0E94 0000 		call process_rgb
 1107               	.LVL99:
 273:quantum/quantum.c **** #endif
 1108               		.loc 1 273 48 discriminator 2 view .LVU220
 1109 0060 8823      		tst r24
 1110 0062 01F0      		breq .L70
 285:quantum/quantum.c ****         switch (keycode) {
 1111               		.loc 1 285 5 is_stmt 1 view .LVU221
 285:quantum/quantum.c ****         switch (keycode) {
 1112               		.loc 1 285 8 is_stmt 0 view .LVU222
 1113 0064 8A81      		ldd r24,Y+2
 1114 0066 8823      		tst r24
 1115 0068 01F0      		breq .L74
 286:quantum/quantum.c **** #ifndef NO_RESET
 1116               		.loc 1 286 9 is_stmt 1 view .LVU223
 1117 006a 0115      		cp r16,__zero_reg__
 1118 006c 8CE5      		ldi r24,92
 1119 006e 1807      		cpc r17,r24
 1120 0070 01F0      		breq .L75
 1121 0072 0F3D      		cpi r16,-33
 1122 0074 1C45      		sbci r17,92
 1123 0076 01F0      		breq .L76
 1124               	.L74:
 324:quantum/quantum.c **** }
 1125               		.loc 1 324 5 view .LVU224
 324:quantum/quantum.c **** }
 1126               		.loc 1 324 12 is_stmt 0 view .LVU225
 1127 0078 CE01      		movw r24,r28
 1128               	/* epilogue start */
 325:quantum/quantum.c **** 
 1129               		.loc 1 325 1 view .LVU226
 1130 007a DF91      		pop r29
 1131 007c CF91      		pop r28
 1132               	.LVL100:
 325:quantum/quantum.c **** 
 1133               		.loc 1 325 1 view .LVU227
 1134 007e 1F91      		pop r17
 1135 0080 0F91      		pop r16
 1136               	.LVL101:
 324:quantum/quantum.c **** }
 1137               		.loc 1 324 12 view .LVU228
 1138 0082 0C94 0000 		jmp process_action_kb
 1139               	.LVL102:
 1140               	.L75:
 289:quantum/quantum.c ****                 return false;
 1141               		.loc 1 289 17 is_stmt 1 view .LVU229
 1142 0086 0E94 0000 		call reset_keyboard
 1143               	.LVL103:
 290:quantum/quantum.c **** #endif
 1144               		.loc 1 290 17 view .LVU230
 1145               	.L70:
 325:quantum/quantum.c **** 
 1146               		.loc 1 325 1 is_stmt 0 view .LVU231
 1147 008a 80E0      		ldi r24,0
 1148               	/* epilogue start */
 1149 008c DF91      		pop r29
 1150 008e CF91      		pop r28
 1151               	.LVL104:
 325:quantum/quantum.c **** 
 1152               		.loc 1 325 1 view .LVU232
 1153 0090 1F91      		pop r17
 1154 0092 0F91      		pop r16
 1155               	.LVL105:
 325:quantum/quantum.c **** 
 1156               		.loc 1 325 1 view .LVU233
 1157 0094 0895      		ret
 1158               	.LVL106:
 1159               	.L76:
 303:quantum/quantum.c ****                 return false;
 1160               		.loc 1 303 17 is_stmt 1 view .LVU234
 1161 0096 0E94 0000 		call eeconfig_init
 1162               	.LVL107:
 304:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 1163               		.loc 1 304 17 view .LVU235
 304:quantum/quantum.c **** #ifdef VELOCIKEY_ENABLE
 1164               		.loc 1 304 24 is_stmt 0 view .LVU236
 1165 009a 00C0      		rjmp .L70
 1166               		.cfi_endproc
 1167               	.LFE130:
 1169               		.text
 1170               	.Letext0:
 1171               		.file 3 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/stdint.h"
 1172               		.file 4 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/lib/avr-gcc/8/gcc/avr/8.4.0/include/stddef.h"
 1173               		.file 5 "tmk_core/common/keyboard.h"
 1174               		.file 6 "tmk_core/common/action.h"
 1175               		.file 7 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../StdRequestType.h"
 1176               		.file 8 "lib/lufa/LUFA/Drivers/USB/Core/AVR8/../DeviceStandardReq.h"
 1177               		.file 9 "lib/lufa/LUFA/Drivers/USB/Core/USBTask.h"
 1178               		.file 10 "lib/lufa/LUFA/Drivers/USB/Core/HostStandardReq.h"
 1179               		.file 11 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/stdio.h"
 1180               		.file 12 "tmk_core/common/report.h"
 1181               		.file 13 "tmk_core/common/host.h"
 1182               		.file 14 "tmk_core/common/debug.h"
 1183               		.file 15 "quantum/keycode_config.h"
 1184               		.file 16 "tmk_core/common/keycode.h"
 1185               		.file 17 "quantum/quantum_keycodes.h"
 1186               		.file 18 "quantum/keymap.h"
 1187               		.file 19 "./quantum/color.h"
 1188               		.file 20 "quantum/rgblight.h"
 1189               		.file 21 "tmk_core/common/action_layer.h"
 1190               		.file 22 "tmk_core/common/timer.h"
 1191               		.file 23 "tmk_core/common/action_util.h"
 1192               		.file 24 "quantum/send_string.h"
 1193               		.file 25 "/usr/local/Cellar/avr-gcc@8/8.4.0_1/avr/include/stdlib.h"
 1194               		.file 26 "quantum/process_keycode/process_unicode_common.h"
 1195               		.file 27 "quantum/process_keycode/process_unicodemap.h"
 1196               		.file 28 "quantum/quantum.h"
 1197               		.file 29 "tmk_core/common/eeconfig.h"
 1198               		.file 30 "quantum/led.h"
 1199               		.file 31 "quantum/backlight/backlight.h"
 1200               		.file 32 "quantum/process_keycode/process_backlight.h"
 1201               		.file 33 "quantum/process_keycode/process_space_cadet.h"
 1202               		.file 34 "quantum/process_keycode/process_magic.h"
 1203               		.file 35 "quantum/process_keycode/process_grave_esc.h"
 1204               		.file 36 "quantum/process_keycode/process_rgb.h"
 1205               		.file 37 "tmk_core/common/bootloader.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 quantum.c
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:4      *ABS*:000000000000003f __SREG__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:12     .text.do_code16:0000000000000000 do_code16
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:155    .text.register_code16:0000000000000000 register_code16
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:213    .text.unregister_code16:0000000000000000 unregister_code16
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:271    .text.tap_code16:0000000000000000 tap_code16
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:310    .text.process_action_kb:0000000000000000 process_action_kb
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:332    .text.process_record_user:0000000000000000 process_record_user
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:354    .text.process_record_kb:0000000000000000 process_record_kb
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:374    .text.post_process_record_user:0000000000000000 post_process_record_user
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:393    .text.post_process_record_kb:0000000000000000 post_process_record_kb
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:412    .text.get_event_keycode:0000000000000000 get_event_keycode
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:527    .text.get_record_keycode:0000000000000000 get_record_keycode
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:559    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:600    .text.set_single_persistent_default_layer:0000000000000000 set_single_persistent_default_layer
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:652    .text.update_tri_layer_state:0000000000000000 update_tri_layer_state
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:825    .text.update_tri_layer:0000000000000000 update_tri_layer
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:867    .text.matrix_init_quantum:0000000000000000 matrix_init_quantum
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:904    .text.matrix_scan_quantum:0000000000000000 matrix_scan_quantum
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:921    .text.api_send_unicode:0000000000000000 api_send_unicode
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:939    .text.startup_user:0000000000000000 startup_user
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:957    .text.shutdown_user:0000000000000000 shutdown_user
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:972    .text.reset_keyboard:0000000000000000 reset_keyboard
/var/folders/_7/b1vvw0zx42g3yw9l_q10bzth0000gn/T//ccmpNd5J.s:1020   .text.process_record_quantum:0000000000000000 process_record_quantum

UNDEFINED SYMBOLS
register_weak_mods
register_mods
register_code
unregister_code
unregister_weak_mods
unregister_mods
disable_action_cache
layer_switch_get_layer
update_source_layers_cache
keymap_key_to_keycode
read_source_layers_cache
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
eeconfig_is_enabled
eeconfig_init
led_init_ports
backlight_init_ports
unicode_input_mode_init
matrix_init_kb
matrix_scan_kb
clear_keyboard
bootloader_jump
process_backlight
process_unicode_common
process_space_cadet
process_magic
process_grave_esc
process_rgb
